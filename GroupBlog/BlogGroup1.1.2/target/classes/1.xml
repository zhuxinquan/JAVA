
<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" title="XSL Formatting" href="/rss.xsl" media="all" ?>
<rss version="2.0">
    <channel>
        <title>zhuxinquan61的博客</title>
        <image>
            <link>http://blog.csdn.net</link>
            <url>http://static.blog.csdn.net/images/logo.gif</url>
        </image>
        <description></description>
        <link>http://blog.csdn.net/zhuxinquan61</link>
        <language>zh-cn</language>
        <generator>http://blog.csdn.net</generator>
        <ttl>5</ttl>
        <copyright><![CDATA[Copyright &copy; zhuxinquan61]]></copyright>
        <pubDate>2016/4/14 12:10:35</pubDate>
        <item>
            <title><![CDATA[[原]JDBC连接并使用mysql数据库]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50651431</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50651431</guid>
            <author>zhuxinquan61</author>
            <pubDate>2016/2/26 9:49:23</pubDate>
            <description><![CDATA[
            <p>数据库在开发过程中是非常容易使用到的，在java的开发中也有一套工具方便我们对于数据库的连接和操作，那就是jdbc。 <br>
jdbc是一套连接数据库的工具，在使用时，通常包括以下步骤：</p>

<ol>
<li>加载数据库驱动程序——jdbc作为工具并不包含在jdk中，我们在使用前需要去加载该类</li>
<li>获取数据库连接对象——如同访问网站一样，我们需要建立与数据库的链接</li>
<li>构造sql语句——sql语句为字符串，如同在sql客户端执行的语句是相同的</li>
<li>构造Statement实例——Statement实例是sql语句的载体</li>
<li>执行sql语句——sql语句由数据库执行，需要通过Statement载体发送给数据库再去执行</li>
<li>关闭连接——关闭Statement实例连接，关闭数据库连接对象的连接</li>
</ol>

<p>下面是一段数据库插入操作的源码：</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**
     * 插入操作
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>(){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//加载数据库驱动程序</span>
            Class.forName(Driver);
            <span class="hljs-comment">//获取数据库连接对象</span>
            Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWD);
            <span class="hljs-comment">//构造sql语句</span>
            String sql = <span class="hljs-string">" insert into person(name, age, description) values('测试', 20, '测试1');"</span>;
            <span class="hljs-comment">//构造statment实例（用来发送SQL语句的载体）</span>
            Statement stat = conn.createStatement();
            <span class="hljs-comment">//执行sql语句（发送给数据库）</span>
            <span class="hljs-keyword">int</span> num = stat.executeUpdate(sql);
            System.out.println(num);
            <span class="hljs-comment">//关闭连接</span>
            stat.close();
            conn.close();
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        }
    }</code></pre>

<p>需要注意的是，在建立Mysql链接使用的URL中，为了防止字符集不匹配的情况，我们需要指定字符集，方式如下：</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String URL = <span class="hljs-string">"jdbc:mysql://localhost:3306/test?characterEncoding=utf-8"</span>;</code></pre>

<p>其中localhost：3306为数据库服务器地址，test为要使用的数据库，在其之后的characterEncoding=utf-8是指定的字符集。</p>

<p><br></p>

<p><br> <br>
上面是一个简单的插入操作,插入的是一个纯粹的字符串组成的sql语句，在实际应用中，我们可能不能确定将要插入的字符，所以我们需要通过预先编译的sql语句将即将要执行的sql语句（不含字段值）存储起来，然后在执行前给预先编译好的sql语句进行设置值操作，如下，通过实现PreparedStatement接口进行操作：</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> JdbcConnect;

<span class="hljs-keyword">import</span> java.sql.Connection;
<span class="hljs-keyword">import</span> java.sql.DriverManager;
<span class="hljs-keyword">import</span> java.sql.PreparedStatement;
<span class="hljs-keyword">import</span> java.sql.SQLException;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-2-5.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreparedStatementDemo</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String URL = <span class="hljs-string">"jdbc:mysql://localhost:3306/test?characterEncoding=utf-8"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String USERNAME = <span class="hljs-string">"root"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String PASSWD = <span class="hljs-string">"××××××××"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String Driver = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;


    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>(Person p){
        <span class="hljs-keyword">try</span> {
            Class.forName(Driver);
            Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWD);
            String sql = <span class="hljs-string">"insert into person(name, age, description) values(?, ?, ?)"</span>;
            PreparedStatement ps = conn.prepareStatement(sql);
            <span class="hljs-comment">//设置字段值</span>
            ps.setString(<span class="hljs-number">1</span>, p.getName());
            ps.setInt(<span class="hljs-number">2</span>, p.getAge());
            ps.setString(<span class="hljs-number">3</span>, p.getDescription());

            ps.executeUpdate();
            ps.close();
            conn.close();


        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"测试3"</span>, <span class="hljs-number">23</span>, <span class="hljs-string">"ceshi 3"</span>);
        insert(p);
    }
}</code></pre>

<p><br>
在上面这段代码中并没有将字段的具体值写入字符串中，而是通过PreparedStatement类去设置之前通过通配符表示的字段值。进而去执行已经预编译好的sql语句。 <br>
<br>
更新操作完成后的sql语句返回影响的行数，而查询操作完成后返回的是ResultSet结果集，我们需要对其结果进行处理才能得到我们想要的结果，如下例就是一个简单的查询操作：</p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> JdbcConnect;

<span class="hljs-keyword">import</span> java.sql.*;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-2-4.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbaQueryDemo</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String URL = <span class="hljs-string">"jdbc:mysql://localhost:3306/test?characterEncoding=utf-8"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String USERNAME = <span class="hljs-string">"root"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String PASSWD = <span class="hljs-string">"××××××××"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String Driver = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span>(){
        <span class="hljs-keyword">try</span> {
            Class.forName(Driver);
            Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWD);
            String sql = <span class="hljs-string">"select id, name, age, description from person"</span>;
            Statement state = conn.createStatement();
            <span class="hljs-comment">//返回查询的结果集</span>
            ResultSet rs = state.executeQuery(sql);
            <span class="hljs-keyword">while</span> (rs.next()){
                <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-number">1</span>);
                System.out.println(id);
            }
            rs.close();
            state.close();
            conn.close();
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        query();
    }
}</code></pre>

<p><br>
同样当我们要查询的条件不确定时，我们也可以通过使用PreparedStatement接口利用通配符的方式，之后设置字段值实现预想的要求。</p>
            <div>
                作者：zhuxinquan61 发表于2016/2/26 9:49:23 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50651431">原文链接</a>
            </div>
            <div>
            阅读：64 评论：1 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50651431#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]SAX解析XML]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50562312</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50562312</guid>
            <author>zhuxinquan61</author>
            <pubDate>2016/1/22 16:54:19</pubDate>
            <description><![CDATA[
            <p>上一篇简单介绍了dom解析xml文件的用法，但是dom解析有一个缺点，就是dom解析前需要将xml文件一次性的读入内存当中，而SAX解析则解决了这个问题。</p>



<h3 id="sax是simple-api-for-xml的简写既是一种接口也是一种软件包">SAX：是Simple API for XML的简写，既是一种接口，也是一种软件包。</h3>

<p>SAX是一种XML解析的替代方法。SAX不同于DOM解析，它逐行扫描文档，一边扫描一边解析，所以它内存占用少，对于大型文档的解析是个很好的优势。</p>



<h4 id="首先是解析的步骤">首先是解析的步骤：</h4>

<ol>
<li>创建SAX解析器工厂对象； SAXParseFactory spf = SAXParserFactory.newInstance();</li>
<li>使用解析器工厂创建解析器实例；SAXParse saxParser = spf.newSAXParser();</li>
<li>创建xml内容解析器对象；PersonHandler ph = new PersonHandler(); <br>
<ol><li>开始解析文档调用的方法</li>
<li>结束解析文档调用的方法</li>
<li>解析开始元素调用的方法</li>
<li>解析结束元素调用的方法</li>
<li>解析文本内容调用的方法</li></ol></li>
<li>创建xml文件输入流，开始解析xml文件：</li>
</ol>

<p>SAX是从上往下依次解析xml文档的，所以解析的过程并不具备层次性，从输入流开始的地方解析，根据解析到的不同的元素、内容回调合适的方法进行解析，下面是一个以teacher.xml文件为例的解析实例， 将从xml文件中解析出来的teacher的id、name以及desc存入一个Teacher对象中，病输出：</p>



<h4 id="teacherxml文件如下"><strong>teacher.xml文件如下：</strong></h4>



<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">person</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">teacher</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">desc</span>&gt;</span>小白人<span class="hljs-tag">&lt;/<span class="hljs-title">desc</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">teacher</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">teacher</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>小黑<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">desc</span>&gt;</span>小黑人<span class="hljs-tag">&lt;/<span class="hljs-title">desc</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">teacher</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">person</span>&gt;</span></code></pre>



<h4 id="要存入的teacher类定义如下">要存入的Teacher类定义如下：</h4>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> xml;
<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-1-20.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> {</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String desc;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Teacher{"</span> +
                <span class="hljs-string">"id="</span> + id +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", desc='"</span> + desc + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span>() {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span>(<span class="hljs-keyword">int</span> id, String name, String desc) {

        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.desc = desc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span>() {

        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span>() {
        <span class="hljs-keyword">return</span> desc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span>(String desc) {
        <span class="hljs-keyword">this</span>.desc = desc;
    }
}</code></pre>



<h4 id="下面是sax解析xml文件的源代码">下面是SAX解析xml文件的源代码：</h4>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> xml;

<span class="hljs-keyword">import</span> org.xml.sax.InputSource;
<span class="hljs-keyword">import</span> org.xml.sax.SAXException;

<span class="hljs-keyword">import</span> javax.xml.parsers.ParserConfigurationException;
<span class="hljs-keyword">import</span> javax.xml.parsers.SAXParser;
<span class="hljs-keyword">import</span> javax.xml.parsers.SAXParserFactory;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-1-22.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaxParseDemo</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> ParserConfigurationException, SAXException, IOException {
        <span class="hljs-comment">//创建SAX解析器工厂</span>
        SAXParserFactory factory = SAXParserFactory.newInstance();
        <span class="hljs-comment">//根据工厂创建解析器对象</span>
        SAXParser sax = factory.newSAXParser();

        PersonHandler ph = <span class="hljs-keyword">new</span> PersonHandler();
        <span class="hljs-comment">//开始解析</span>
        sax.parse((InputStream) <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"teacher.xml"</span>), ph);
        List&lt;Teacher&gt; list = ph.getTeachers();
        System.out.println(list);
    }
}</code></pre>



<h4 id="如同上面介绍的步骤一样该文件主要定义解析器工厂解析器对象以及声明内容解析对象xml文件的主要解析在与定义的内容解析内容如下">如同上面介绍的步骤一样，该文件主要定义解析器工厂、解析器对象以及声明内容解析对象，xml文件的主要解析在与定义的内容解析内容，如下：</h4>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> xml;

<span class="hljs-keyword">import</span> org.xml.sax.Attributes;
<span class="hljs-keyword">import</span> org.xml.sax.SAXException;
<span class="hljs-keyword">import</span> org.xml.sax.helpers.DefaultHandler;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-javadoc">/**
 * SAX解析的内容处理器
 * 进行回调使用
 * Created by zhuxinquan on 16-1-22.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultHandler</span> {</span>

    <span class="hljs-keyword">private</span> List&lt;Teacher&gt; teachers = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> Teacher teacher;
    <span class="hljs-keyword">private</span> String tag;


    <span class="hljs-comment">//开始解析文档时调用的方法</span>

    <span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">getTeachers</span>() {
        <span class="hljs-keyword">return</span> teachers;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeachers</span>(List&lt;Teacher&gt; teachers) {
        <span class="hljs-keyword">this</span>.teachers = teachers;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDocument</span>() <span class="hljs-keyword">throws</span> SAXException {
        teachers = <span class="hljs-keyword">new</span> ArrayList&lt;Teacher&gt;();
    }


    <span class="hljs-javadoc">/**
     * 解析开始标签时调用的方法
     *<span class="hljs-javadoctag"> @param</span> uri:命名空间
     *<span class="hljs-javadoctag"> @param</span> localName：元素的本地名称，即元素名（标签名），不带前缀
     *<span class="hljs-javadoctag"> @param</span> qName：带前缀的元素名称
     *<span class="hljs-javadoctag"> @param</span> attributes：存储标签元素的属性
     *<span class="hljs-javadoctag"> @throws</span> SAXException
     */</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startElement</span>(String uri, String localName, String qName, Attributes attributes) <span class="hljs-keyword">throws</span> SAXException {
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"teacher"</span>.equals(qName)){
            teacher = <span class="hljs-keyword">new</span> Teacher();
            <span class="hljs-comment">//取出属性并添加到teacher中</span>
            teacher.setId(Integer.parseInt(attributes.getValue(<span class="hljs-string">"id"</span>)));
        }
        tag = qName;
    }

    <span class="hljs-comment">//解析结束标签时调用的方法</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endElement</span>(String uri, String localName, String qName) <span class="hljs-keyword">throws</span> SAXException {
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"teacher"</span>.equals(qName)){
            teachers.add(teacher);
        }
        tag = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">//xml文档解析完成调用的方法</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endDocument</span>() <span class="hljs-keyword">throws</span> SAXException {
        System.out.println(<span class="hljs-string">"XML解析完毕！"</span>);
    }

    <span class="hljs-comment">//解析文本内容时调用的方法</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">characters</span>(<span class="hljs-keyword">char</span>[] ch, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> length) <span class="hljs-keyword">throws</span> SAXException {
        <span class="hljs-keyword">if</span>(tag != <span class="hljs-keyword">null</span>){
            <span class="hljs-comment">//取出属性并添加到teacher中</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-string">"name"</span>.equals(tag)){
                teacher.setName(<span class="hljs-keyword">new</span> String(ch, start, length));
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"desc"</span>.equals(tag)){
                teacher.setDesc(<span class="hljs-keyword">new</span> String(ch, start, length));
            }
        }
    }
}</code></pre>



<h4 id="sax解析的内容处理器一般继承defaulthandler类该类中包含了处理xml文档的元素以及文本的许多处理方法在实际应用中需要使用什么方法时再去实现它">SAX解析的内容处理器一般继承DefaultHandler类，该类中包含了处理xml文档的元素以及文本的许多处理方法，在实际应用中需要使用什么方法时，再去实现它。</h4>



<h4 id="上面几个源代码可以在这里找到">上面几个源代码可以在<a href="https://github.com/zhuxinquan/JAVA/tree/master/XMLExercise" target="&quot;_blank">这里找到</a>;</h4>

<h5 id="初次学习错误之处还望指正">！！初次学习，错误之处还望指正～～～</h5>
            <div>
                作者：zhuxinquan61 发表于2016/1/22 16:54:19 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50562312">原文链接</a>
            </div>
            <div>
            阅读：51 评论：1 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50562312#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]使用DOM解析XML文件]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50555709</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50555709</guid>
            <author>zhuxinquan61</author>
            <pubDate>2016/1/21 20:55:33</pubDate>
            <description><![CDATA[
            <p>XML是一种可扩展的标记语言，首先它是一种标记语言，类似于HTML，有标签，标签有属性，然而与HTML不同的是XML的标签是可以自己定义的，这样就方便我们存储一些有层次结构的内容！ <br>
<strong>这里要说的是使用DOM去解析XML文件：</strong> <br>
首先，DOM是一种文档对象模型（Document Object Model），使用DOM解析时会将XML文档表示为树状，具有层次性。 <br>
如下是一个xml文件的例子：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">person</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">teacher</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">desc</span>&gt;</span>小白人<span class="hljs-tag">&lt;/<span class="hljs-title">desc</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">teacher</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">teacher</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>小黑<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">desc</span>&gt;</span>小黑人<span class="hljs-tag">&lt;/<span class="hljs-title">desc</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">teacher</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">person</span>&gt;</span></code></pre>

<p>第一行为xml文件声明的头，包括版本号和字符编码 <br>
接下来是实体内容，&lt;person&gt;是自定义的标签，里面包含两个teacher标签，id是标签的属性，标签内部可以嵌套使用标签，成为子标签</p>



<h4 id="对一个xml文件解析通常有以下几个步骤">对一个XML文件解析通常有以下几个步骤：</h4>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//首先创建Dom解析器工厂</span>
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
<span class="hljs-comment">//通过解析器工厂创建解析器</span>
DocumentBuilder builder = dbf.newDocumentBuilder();
<span class="hljs-comment">//创建Document对象开始解析，is为xml文件输入流，解析的过程就如同形成一棵树的过程</span>
Document doc = builder.parse(<span class="hljs-keyword">is</span>);
<span class="hljs-comment">//根据文档的节点返回NodeList列表</span>
NodeList nodelist =  doc.getElementsByTagName(<span class="hljs-string">"teacher"</span>);</code></pre>

<p>下面是一个例子，通过一个XML文件中的数据创建Teacher对象，Teacher类的定义如下：</p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> xml;
<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-1-20.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> {</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String desc;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Teacher{"</span> +
                <span class="hljs-string">"id="</span> + id +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", desc='"</span> + desc + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span>() {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span>(<span class="hljs-keyword">int</span> id, String name, String desc) {

        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.desc = desc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span>() {

        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span>() {
        <span class="hljs-keyword">return</span> desc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span>(String desc) {
        <span class="hljs-keyword">this</span>.desc = desc;
    }
}</code></pre>

<p>下面是解析使用的DomParseDemo类：</p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> xml;

<span class="hljs-keyword">import</span> org.w3c.dom.Document;
<span class="hljs-keyword">import</span> org.w3c.dom.Node;
<span class="hljs-keyword">import</span> org.w3c.dom.NodeList;
<span class="hljs-keyword">import</span> org.xml.sax.SAXException;

<span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilder;
<span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;
<span class="hljs-keyword">import</span> javax.xml.parsers.ParserConfigurationException;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-1-20.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DomParseDemo</span> {</span>
    <span class="hljs-javadoc">/**
     * 一个解析类对应一个xml文件
     *<span class="hljs-javadoctag"> @throws</span> IOException
     *<span class="hljs-javadoctag"> @throws</span> ParserConfigurationException
     *<span class="hljs-javadoctag"> @throws</span> SAXException
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> IOException, ParserConfigurationException, SAXException {
        <span class="hljs-comment">//创建Dom解析器工厂</span>
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        <span class="hljs-comment">//通过解析器工厂创建解析器</span>
        DocumentBuilder builder = dbf.newDocumentBuilder();
        <span class="hljs-comment">//构造一个输入流</span>
        InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"teacher.xml"</span>);
        <span class="hljs-comment">//开始解析，创建Document对象</span>
        Document doc = builder.parse(is);

        <span class="hljs-comment">//存储Teacher的集合</span>
        List&lt;Teacher&gt; teachers = <span class="hljs-keyword">new</span> ArrayList&lt;Teacher&gt;();
        Teacher t = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">//根据文档的结点获取数据，返回一个NodeList列表</span>
        NodeList nodelist =  doc.getElementsByTagName(<span class="hljs-string">"teacher"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodelist.getLength(); i++) {
            t = <span class="hljs-keyword">new</span> Teacher();
            <span class="hljs-comment">//item返回值为一个结点，返回一个Node对象</span>
            Node teachernode =  nodelist.item(i);
            <span class="hljs-comment">//getAttributes取得当前结点下的所有属性,getNameItem根据属性名称获取当前属性</span>
            String id = teachernode.getAttributes().getNamedItem(<span class="hljs-string">"id"</span>).getNodeValue();
<span class="hljs-comment">//            System.out.println(id);</span>
            t.setId(Integer.parseInt(id));
            <span class="hljs-comment">//获取当前节点下的所有子节点列表</span>
            NodeList childNodeList = teachernode.getChildNodes();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; childNodeList.getLength(); j++) {
                <span class="hljs-comment">//获取teacher节点下的其中一个子节点</span>
                Node childNode = childNodeList.item(j);
                String tagName = childNode.getNodeName();
                <span class="hljs-keyword">if</span>(<span class="hljs-string">"name"</span>.equals(tagName)){
                    <span class="hljs-comment">//获取teacher节点下的name节点的值</span>
                    t.setName(childNode.getFirstChild().getNodeValue());
                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"desc"</span>.equals(tagName)){
                    <span class="hljs-comment">//获取teacher节点下的desc值</span>
                    t.setDesc(childNode.getFirstChild().getNodeValue());
                }<span class="hljs-keyword">else</span>{
                    System.out.println(childNode.getFirstChild().getNodeValue());
                }
            }
            teachers.add(t);
        }
        System.out.println(teachers);
    }
}</code></pre>

<p>以上是一个比较简单的通过Dom去解析xml文件的例子，对于不同的xml文件需要定义不同的解析器，对于解析xml文件实质就是通过不同的标签获取到不同的内容，对应于最深层子标签中的内容是通过子标签getNodeValue获取的，也就是说，任何标签内的子标签是被当做上层标签的内容一块获取的。 <br>
！！初次学习，错误之处还望指正～～～</p>
            <div>
                作者：zhuxinquan61 发表于2016/1/21 20:55:33 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50555709">原文链接</a>
            </div>
            <div>
            阅读：51 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50555709#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]JavaIO操作之  字节  输入输出流]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50524427</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50524427</guid>
            <author>zhuxinquan61</author>
            <pubDate>2016/1/16 14:43:18</pubDate>
            <description><![CDATA[
            <p>在Java中IO流主要分为两大部分：字节流和字符流，这里要说的就是第一种字节流</p>

<h4 id="字节流也分为两大部分输入流和输出流">字节流也分为两大部分：<strong>输入流</strong>和<strong>输出流</strong></h4>



<h4 id="首先是输入流"><strong>首先是输入流：</strong></h4>

<p>输入流包含以下3种简单的输入数据的方法：</p>

<ul>
<li><strong>read()</strong>;    //从输入流中读取数据的下一个字节，返回一个int型字节，如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</li>
<li><strong>read(byte[] b)</strong>;  //从输入流中读取一定数量的字节，并将其存入缓冲数组b中，并以整数的形式返回<strong>实际读取</strong>的字节数，如果因为流位于文件末尾而没有可用的字节，则返回值 -1。</li>
<li><strong>read(byte[] b, int off, int len)</strong>； //将输入流中最多 len 个数据字节读入 byte 数组，将读取的<strong>第一个字节存储在元素 b[off]</strong> 中，下一个存储在 b[off+1] 中，依次类推。在任何情况下，b[0] 到 b[off] 的元素以及 b[off+len] 到 b[b.length-1] 的元素都不会受到影响。返回读入缓冲区的的总字节数，同样，如果因为流位于文件末尾而没有可用的字节，则返回值 -1。</li>
</ul>

<p>下面是一个使用字节输入流显示文件的例子：</p>



<pre class="prettyprint"><code class=" hljs cs">import jdk.<span class="hljs-keyword">internal</span>.org.objectweb.asm.tree.analysis.SourceInterpreter;
import jdk.<span class="hljs-keyword">internal</span>.util.xml.impl.Input;

import java.io.*;

<span class="hljs-comment">/**
 * Created by zhuxinquan on 16-1-15.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> InputStreamDemo {

    <span class="hljs-comment">//一次性读取所有的字节</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read1</span>() throws IOException {
        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>);
        InputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(f);
        <span class="hljs-comment">//根据文件大小构造字符数组</span>
        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)f.length()];       <span class="hljs-comment">//通过使用f.length获取到该文件总共有多少字节</span>
        <span class="hljs-keyword">int</span> len = <span class="hljs-keyword">in</span>.read(bytes);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> String(bytes));
        <span class="hljs-keyword">in</span>.close();
    }

    <span class="hljs-comment">//每次读取一个字节</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read2</span>() throws IOException {
        InputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"./test.txt"</span>);
        <span class="hljs-keyword">int</span> b = -<span class="hljs-number">1</span>;
        <span class="hljs-comment">//in.read的返回值为int类型</span>
        <span class="hljs-keyword">while</span>((b = <span class="hljs-keyword">in</span>.read()) != -<span class="hljs-number">1</span>){
            System.<span class="hljs-keyword">out</span>.print((<span class="hljs-keyword">char</span>)b);
        }
        <span class="hljs-keyword">in</span>.close();
    }

    <span class="hljs-comment">//每次获取指定长度个字节</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read3</span>() throws IOException {
        InputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"./test.txt"</span>);
        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;   <span class="hljs-comment">//存储每次读取的实际长度</span>
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span>((len = <span class="hljs-keyword">in</span>.read(bytes)) != -<span class="hljs-number">1</span>){
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len) + <span class="hljs-string">" "</span>  + <span class="hljs-string">"len = "</span> + len);
            sb.append(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len));
        }
        System.<span class="hljs-keyword">out</span>.println(sb);
        <span class="hljs-keyword">in</span>.close();
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws IOException {
        read3();
    }
}
</code></pre>



<h3 id="接下来是输出流">接下来是输出流</h3>

<p>输出流包含也包含以下3种简单的将数据输出到文件的方法：</p>

<ul>
<li>write(byte[] b); //将b.length个字节从指定byte数组写入文件输出流中</li>
<li>write(byte[] b, int off, int len); //将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</li>
<li>write(int b); //将指定字节写入此文件输出流。该方法参数中的int b为字符的ascii码值，输出时将对应的字符写入文件输出流中。 <br>
下面是一个使用输出流方法将数据写入文件的例子：</li>
</ul>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.OutputStream;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 16-1-15.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputStresmDemo</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write1</span>(){
        <span class="hljs-keyword">try</span>{
            OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"./test.txt"</span>);
            String info = <span class="hljs-string">"hello IO"</span>;
            <span class="hljs-keyword">byte</span>[] bytes = info.getBytes();
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; info.length(); i++){
                out.write(bytes[i]);        <span class="hljs-comment">//一个一个将字节写入字节输出流并写入文件</span>
            }
            out.write(bytes);       <span class="hljs-comment">//将一个字节数组一次性的写入输出流并写入文件当中</span>
            out.write(<span class="hljs-number">97</span>);          <span class="hljs-comment">//将一个字节数（ascii值）转换为字符输出到文件输出流并写入文件中</span>
            out.close();
        }<span class="hljs-keyword">catch</span> (FileNotFoundException e){
            e.printStackTrace();
        }<span class="hljs-keyword">catch</span> (IOException e){
            e.printStackTrace();
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        write1();
    }
}</code></pre>

<p>这里是一些字节输入输出流的方法，每次文件流的读写操作都是基于字节进行的，接下来就是<strong>字符</strong>输入输出流了……</p>

<p>！！出错之处请指正～～～</p>
            <div>
                作者：zhuxinquan61 发表于2016/1/16 14:43:18 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50524427">原文链接</a>
            </div>
            <div>
            阅读：44 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50524427#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]一个简单的爬虫(1)]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50495504</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50495504</guid>
            <author>zhuxinquan61</author>
            <pubDate>2016/1/11 21:01:43</pubDate>
            <description><![CDATA[
            <h4 id="在学习了简单的java语法之后练习使用java做一个简单的爬虫将一个电影网页的电影介绍爬下来首先需要了解爬虫是什么">在学习了简单的java语法之后，练习使用java做一个简单的爬虫，将一个电影网页的电影介绍爬下来，首先需要了解爬虫是什么！</h4>

<blockquote>
  <h3 id="网络爬虫简称爬虫又名网页蜘蛛网络机器人是一种按照按照一定的规则自动地抓取万维网信息的程序或者脚本">网络爬虫（简称爬虫，又名网页蜘蛛、网络机器人），是一种按照按照<strong>一定的规则</strong>，自动地抓取万维网信息的程序或者脚本。</h3>
</blockquote>



<h4 id="在了解了网络爬虫的概念之后我们需要知道如何去爬首先我们需要获取到这些信息如同我们访问网页请求链接返回我们需要的数据一样我们需要首先获取到网页的信息这里我们使用的是jsoup中从一个url加载一个document这里的可以参考jsoup使用手册事实上我们这里通过jsoup获取到的就是整个网页的源码同时jsoup有许多处理此源码的方法在这篇中用的是正则匹配来进行爬虫操作">在了解了网络爬虫的概念之后，我们需要知道如何去爬，首先我们需要获取到这些信息，如同我们访问网页请求链接返回我们需要的数据一样，我们需要首先获取到网页的信息，这里我们使用的是jsoup中从一个URL加载一个Document，这里的可以参考<a href="http://www.open-open.com/jsoup/load-document-from-url.htm">jsoup使用手册</a>,事实上我们这里通过jsoup获取到的就是整个网页的源码，同时jsoup有许多处理此源码的方法，在这篇中用的是正则匹配来进行爬虫操作。</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;首先使用Document 的toString方法将Document文档全部转化为字符串，然后使用字符串进行相应的片段匹配。这里要用到了以下的匹配规则：</p>

<pre class="prettyprint"><code class=" hljs mathematica"><span class="hljs-keyword">Pattern</span> reg_htm = <span class="hljs-keyword">Pattern</span>.compile(<span class="hljs-string">"&lt;[^&gt;]+&gt;"</span>);
//用来匹配html标签，当我们匹配到一段主要信息之后，该短信息往往是包含一些html标签的，我们需要将这些html标签替换为空（即删除这些html标签）
<span class="hljs-keyword">Pattern</span> reg_name_ = <span class="hljs-keyword">Pattern</span>.compile(<span class="hljs-string">"&amp;middot;"</span>);
//用来匹配演员英文名称中的姓氏与名字之间的点，由于名字中间的点在html源码中是使用转义的字符的，所以得到的字符串也是&amp;middot；所以我们仍需要对它进行替换回去
<span class="hljs-keyword">Pattern</span> p = <span class="hljs-keyword">Pattern</span>.compile(<span class="hljs-string">"&lt;span property=\"v:itemre.*&lt;/span&gt;"</span>);
//该项目的匹配是采用html标签以及标签内的内容组合的方式进行匹配，匹配的内容是电影的名字，往往每一个字段对会有特殊的class或id以及一些特殊的属性，所以可以根据这些属性进行匹配。</code></pre>



<h4 id="上面是要进行匹配的一些正则及其用处是一些要进行匹配的规则接下来我们要对匹配的字符串进行处理第一个处理就是摘取出匹配的部分使用patternmatchstring进行匹配的查找得到所有能够匹配的位置实质上该方法返回值为boolean类型表明匹配成功或者匹配失败然后使用find方法判断是否存在匹配的结果然后依次取该结果输出当需要进行替换或者html代码需要进行删除时分别再次使用不同的正则进行匹配替换最后输出结果同时还可利用java-io操作将要输出的内容存成文件方便下次查看">上面是要进行匹配的一些正则及其用处，是一些要进行匹配的规则，接下来我们要对匹配的字符串进行处理，第一个处理就是摘取出匹配的部分，使用Pattern.match(String)进行匹配的查找，得到所有能够匹配的位置（实质上该方法返回值为Boolean类型，表明匹配成功或者匹配失败），然后使用.find()方法判断是否存在匹配的结果，然后依次取该结果，输出，当需要进行替换或者html代码需要进行删除时分别再次使用不同的正则进行匹配替换，最后输出结果，同时，还可利用Java I/O操作，将要输出的内容存成文件，方便下次查看。</h4>

<p>下面是一个简单的豆瓣电影介绍的爬虫示例：</p>

<pre class="prettyprint"><code class=" hljs avrasm">package Jsoup<span class="hljs-comment">;</span>


import org<span class="hljs-preprocessor">.jsoup</span>.*<span class="hljs-comment">;</span>
import org<span class="hljs-preprocessor">.jsoup</span><span class="hljs-preprocessor">.nodes</span>.*<span class="hljs-comment">;</span>

import javax<span class="hljs-preprocessor">.sound</span><span class="hljs-preprocessor">.midi</span><span class="hljs-preprocessor">.SysexMessage</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.io</span><span class="hljs-preprocessor">.IOException</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.regex</span><span class="hljs-preprocessor">.Matcher</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.regex</span><span class="hljs-preprocessor">.Pattern</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/**
 * Created by zhuxinquan on 15-12-15.
 */</span>
public class Test {
    public static void main(String[] args) throws IOException {
        Document doc = Jsoup<span class="hljs-preprocessor">.connect</span>(<span class="hljs-string">"http://movie.douban.com/subject/25809384/?from=showing"</span>)<span class="hljs-preprocessor">.timeout</span>(<span class="hljs-number">5000</span>)<span class="hljs-preprocessor">.get</span>()<span class="hljs-comment">;</span>
        String html = doc<span class="hljs-preprocessor">.toString</span>()<span class="hljs-comment">;</span>
        String s = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
        Pattern reg_htm = Pattern<span class="hljs-preprocessor">.compile</span>(<span class="hljs-string">"&lt;[^&gt;]+&gt;"</span>)<span class="hljs-comment">;</span>
        Pattern reg_name_ = Pattern<span class="hljs-preprocessor">.compile</span>(<span class="hljs-string">"&amp;middot;"</span>)<span class="hljs-comment">;</span>
        Pattern p = Pattern<span class="hljs-preprocessor">.compile</span>(<span class="hljs-string">"&lt;span property=\"v:itemre.*&lt;/span&gt;"</span>)<span class="hljs-comment">;</span>
        Matcher m = p<span class="hljs-preprocessor">.matcher</span>(html)<span class="hljs-comment">;</span>
        while(m<span class="hljs-preprocessor">.find</span>()){
            s = m<span class="hljs-preprocessor">.group</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
        }
        m = reg_htm<span class="hljs-preprocessor">.matcher</span>(s)<span class="hljs-comment">;</span>
        s = m<span class="hljs-preprocessor">.replaceAll</span>(<span class="hljs-string">""</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(s)<span class="hljs-comment">;</span>
        p = Pattern<span class="hljs-preprocessor">.compile</span>(<span class="hljs-string">"(?s)&lt;span class=\"pl\"&gt;.*?&lt;/span&gt;&lt;/span&gt;.*?&lt;br /&gt;"</span>)<span class="hljs-comment">;</span>
        m = p<span class="hljs-preprocessor">.matcher</span>(html)<span class="hljs-comment">;</span>
        while (m<span class="hljs-preprocessor">.find</span>()) {
            s = m<span class="hljs-preprocessor">.group</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
            Matcher m1 = reg_htm<span class="hljs-preprocessor">.matcher</span>(s)<span class="hljs-comment">;</span>
            s = m1<span class="hljs-preprocessor">.replaceAll</span>(<span class="hljs-string">""</span>)<span class="hljs-comment">;</span>
            m1 = reg_name_<span class="hljs-preprocessor">.matcher</span>(s)<span class="hljs-comment">;</span>
            s = m1<span class="hljs-preprocessor">.replaceAll</span>(<span class="hljs-string">"·"</span>)<span class="hljs-comment">;</span>
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(s)<span class="hljs-comment">;</span>
        }
        //System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(html)<span class="hljs-comment">;</span>
        p = Pattern<span class="hljs-preprocessor">.compile</span>(<span class="hljs-string">"(?s)(&lt;span class=\"pl\"&gt;.*?&lt;span property=\"v:genre\"&gt;.*?&lt;/span&gt;\n"</span> +
                <span class="hljs-string">"          &lt;br /&gt;)"</span>)<span class="hljs-comment">;</span>
        m = p<span class="hljs-preprocessor">.matcher</span>(html)<span class="hljs-comment">;</span>
        while (m<span class="hljs-preprocessor">.find</span>()) {
            s = m<span class="hljs-preprocessor">.group</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
            Matcher m1 = reg_htm<span class="hljs-preprocessor">.matcher</span>(s)<span class="hljs-comment">;</span>
            s = m1<span class="hljs-preprocessor">.replaceAll</span>(<span class="hljs-string">""</span>)<span class="hljs-comment">;</span>
            m1 = reg_name_<span class="hljs-preprocessor">.matcher</span>(s)<span class="hljs-comment">;</span>
            s = m1<span class="hljs-preprocessor">.replaceAll</span>(<span class="hljs-string">"·"</span>)<span class="hljs-comment">;</span>
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(s)<span class="hljs-comment">;</span>
        }
    }
}</code></pre>

<p>！！初次尝试，错误之处望指正！！</p>
            <div>
                作者：zhuxinquan61 发表于2016/1/11 21:01:43 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50495504">原文链接</a>
            </div>
            <div>
            阅读：58 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50495504#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]关于包装类自动装箱时是否产生相同对象]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50118853</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50118853</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/12/1 13:24:47</pubDate>
            <description><![CDATA[
            <h4 id="在java中包装类可实现自动装箱拆箱一般情况下自动装箱会产生一个新的包装类对象但是对于部分特殊的基本类型值系统将保证其两次装箱产生的是同一个对象"><strong>在java中，包装类可实现</strong>自动装箱拆箱，一般情况下自动装箱会产生一个<strong>新的包装类对象</strong>，但是对于部分特殊的基本类型值，系统将保证其两次装箱产生的是同一个对象。</h4>

<p>比如下面的例子：</p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;

<span class="hljs-javadoc">/**
 * Created by zhuxinquan on 15-11-30.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex6_4</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Integer iObj1 = <span class="hljs-number">100</span>;
        Integer iObj2 = <span class="hljs-number">100</span>;
        Integer iObj3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">100</span>);
        Integer iObj4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span>(iObj1 == iObj2){
            System.out.println(<span class="hljs-string">"iObj1 iObj2相等"</span>);
        }<span class="hljs-keyword">else</span>{
            System.out.println(<span class="hljs-string">"iObj1 iObj2不相等"</span>);
        }
        <span class="hljs-keyword">if</span>(iObj3 == iObj4){
            System.out.println(<span class="hljs-string">"iObj3 iObj4相等"</span>);
        }<span class="hljs-keyword">else</span>{
            System.out.println(<span class="hljs-string">"iObj3 iObj4不相等"</span>);
        }
    }
}
</code></pre>

<p>输出结果如下：</p>

<pre class="prettyprint"><code class=" hljs ">iObj1 iObj2相等
iObj3 iObj4不相等</code></pre>

<p>这是因为在内部Interger 类有一个缓存，它会缓存-128～127之间的整数，所以当使用编译器自动装箱时，对于在-128～127之间的数，编译器会默认返回同一个对象，这种情况只有在使用自动装箱得到实例化对象时才会出现，与Interger包装类相同会出现返回相同对象的还有：</p>

<blockquote>
  <p>boolean型值（true 或 false） <br>
  byte型值 <br>
  int或short型值，范围：-128～127 <br>
  char型值，范围：’\u0000’~’\u007f’</p>
</blockquote>

<p>如果不想出现相同的值返回相同对象的情况，只需要在类实例化时使用new来进行实例化就可以了，如同上例的iObj3和iObj4就是使用new关键字来进行实例化，得到的不是同一个对象。</p>
            <div>
                作者：zhuxinquan61 发表于2015/12/1 13:24:47 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50118853">原文链接</a>
            </div>
            <div>
            阅读：88 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50118853#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]子类和父类构造方法的执行先后问题]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/50118247</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/50118247</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/11/30 20:30:41</pubDate>
            <description><![CDATA[
            <h4 id="在java中如果一个类中没有显式的使用super进行调用超类的构造方法则在执行子类构造方法之前会首先待用父类的构造方法如下">在java中如果一个类中没有显式的使用super()进行调用超类的构造方法，则在执行子类构造方法之前会首先待用父类的构造方法，如下：</h4>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**
 * Created by zhuxinquan on 15-11-24.
 */</span>

class Circle{
    <span class="hljs-keyword">double</span> radius = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(){
        <span class="hljs-comment">//this(0);</span>
        System.out.println(<span class="hljs-string">"Parent radius"</span>+radius);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-keyword">double</span> r){
        radius = r;
        System.out.println(<span class="hljs-string">"Parent radius"</span>+radius);
    }
}

class Cylinder extends Circle{
    <span class="hljs-keyword">double</span> height = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Cylinder</span>(){
        System.out.println(<span class="hljs-string">"height"</span>+height);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex5_5</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        Cylinder obj = <span class="hljs-keyword">new</span> Cylinder();
        System.out.println(obj.radius);
    }
}</code></pre>

<p>在Cylinder类中没有显式的调用super()，则在声明Cylinder类时，首先会调用超类的构造方法，在执行完成超类的构造方法之后再会执行本类的构造方法，就会产生如下的结果: <br>
Parent radius10.0 <br>
height100.0 <br>
10.0</p>
            <div>
                作者：zhuxinquan61 发表于2015/11/30 20:30:41 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50118247">原文链接</a>
            </div>
            <div>
            阅读：59 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/50118247#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]PHP中的数组处理函数]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/49401213</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/49401213</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/11/6 23:18:05</pubDate>
            <description><![CDATA[
            <h4 id="php中数组是一种非常重要的数据组织方式关于数组的处理函数也各式各样下面列举一些常用的数组处理函数">php中数组是一种非常重要的数据组织方式，关于数组的处理函数也各式各样，下面列举一些常用的数组处理函数。</h4>

<blockquote>
  <p><strong>foreach()</strong></p>
</blockquote>

<p>使用foreach函数来遍历数组，有两种语法格式</p>



<pre class="prettyprint"><code class=" hljs php"><span class="hljs-number">1.</span>
<span class="hljs-keyword">foreach</span>(array_expression <span class="hljs-keyword">as</span> <span class="hljs-variable">$value</span>){
    循环体
}
<span class="hljs-number">2.</span>
<span class="hljs-keyword">foreach</span>(array_expression <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt;<span class="hljs-variable">$value</span>){
    循环体
}</code></pre>

<p>第一种是遍历给定的<span>$</span>array_expression 数组，每次循环将当前元素的值赋值给<span>$</span>value,然后将数组内部指针后移一步，第二种格式除了将元素值赋值给<span>$</span>value之外，还将当前元素对应的键名复制给变量<span>$</span>key.</p>

<blockquote>
  <p><strong>each()</strong></p>
</blockquote>

<p>each函数需要传递一个数组作为参数，每次返回当前该数组读取到的元素的键/值对，并向后移动数组指针到下一个元素的位置。键/值对为四个带有元素关联和索引的数组,如下：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$contact</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">"id"</span>=&gt;<span class="hljs-number">1</span>, <span class="hljs-string">"姓名"</span>=&gt;<span class="hljs-string">"hello"</span>);
    <span class="hljs-variable">$id</span> = each(<span class="hljs-variable">$contact</span>);
    print_r(<span class="hljs-variable">$id</span>);
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>在这里print_r输出的结果就是”id”=&gt;1该元素对应的键/值对，为带有四个元素的数组：Array([1]=&gt;1 [value]=&gt;1 [0]=&gt;id [key]=&gt;id).此处的1和value对应的值相同，0和key对应的值相同，当each执行两次之后，再次执行each时就会返回false。</p>

<blockquote>
  <p><strong>list()</strong></p>
</blockquote>

<p>list函数用一步的操作给一组变量赋值，并且list仅能用于数字索引的数组并假定数字索引是从0开始，用法如下：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$info</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">'coffee'</span>, <span class="hljs-string">'bown'</span>,<span class="hljs-string">'caffeine'</span>);
    <span class="hljs-keyword">list</span>(<span class="hljs-variable">$drink</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$power</span>) = <span class="hljs-variable">$info</span>;
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>list将数组中的元素依次赋值给list中的变量，也可如下使用：</p>



<pre class="prettyprint"><code class=" hljs autohotkey">list(, , $power) = $info<span class="hljs-comment">;</span></code></pre>

<blockquote>
  <p><strong>array_values()</strong></p>
</blockquote>

<p>该函数参数为一个数组，返回值为数组中所有元素的值形成的一个新的以数字索引的数组，原数组保持不变</p>

<blockquote>
  <p><strong>array_keys()</strong></p>
</blockquote>

<p>该函数返回数组中的所有的键名，该函数有一个必需参数和两个可选参数，第一个必需参数为要查找的数组，第二个参数为是否制定键名对应的值进行查找，第三个参数为查找是否严格匹配类型，当只有第一个参数时，函数将所有的键名以数字索引构成新的数组返回。当含有两个参数时，函数将只返回值为指定值的键名，当含有三个参数时，函数将严格比较指定值与元素值，只有全等时才会返回。</p>

<blockquote>
  <p><strong>in_array()</strong></p>
</blockquote>

<p>该函数是检查数组中是否存在某个值。该函数有三个参数，第一个参数是要搜索的值，第二个参数是要进行查找的数组，若第一个参数为字符串并且第三个参数为TRUE，则严格区分大小写进行查找，若第一个参数不是字符串，并且第三个参数为TRUE则比较是回进行数据类型的比较，只有当数据类型相同并且值相同时才会返回true。<strong>array_search()</strong>与in_array()函数功能参数相同，也支持对数据类型的严格判断。</p>

<blockquote>
  <p><strong>array_key_exists()</strong></p>
</blockquote>

<p>检查给定的键名或索引是否存在于数组当中，由于数组中的键名是唯一的所以不需要对类型进行比较。<strong>isset()</strong>具有相同的功能，也是对键名或者索引进行检查，但isset()对于数组中的NULL值不会返回TRUE了，而array_key_exists()会。</p>

<blockquote>
  <p><strong>array_flip()</strong></p>
</blockquote>

<p>该函数交换数组中的键和值，返回一个反转之后的数组，该函数只有个参数，为要进行反转的数组，若同一个值出现多次时将最后一个键名作为它的值，覆盖前面出现的元素，原数组中值的数据类型必须是字符串或者整数，否则函数将报错。</p>

<blockquote>
  <p><strong>array_reverse()</strong></p>
</blockquote>

<p>将原数组中的元素的顺序进行反转创建新的数组并返回，函数有两个参数，第一个参数为一个数组，第二个参数可选，若原数组索引为默认数字索引且指定为true则元素的键名与值成对保持不变，否则键名将丢失，重新生成数字索引，如下两种结果：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$lamp</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">"os"</span>, <span class="hljs-string">"linux"</span>, <span class="hljs-string">"webserver"</span>, <span class="hljs-string">"apache"</span>, <span class="hljs-string">"database"</span>, <span class="hljs-string">"mysql"</span>);
    print_r(array_reverse(<span class="hljs-variable">$lamp</span>));
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>执行结果为：</p>



<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">Array</span>
(
    [<span class="hljs-number">0</span>] =&gt; mysql
    [<span class="hljs-number">1</span>] =&gt; database
    [<span class="hljs-number">2</span>] =&gt; apache
    [<span class="hljs-number">3</span>] =&gt; webserver
    [<span class="hljs-number">4</span>] =&gt; linux
    [<span class="hljs-number">5</span>] =&gt; os
)</code></pre>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$lamp</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">"os"</span>, <span class="hljs-string">"linux"</span>, <span class="hljs-string">"webserver"</span>, <span class="hljs-string">"apache"</span>, <span class="hljs-string">"database"</span>, <span class="hljs-string">"mysql"</span>);
    print_r(array_reverse(<span class="hljs-variable">$lamp</span>，<span class="hljs-keyword">true</span>));
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p><strong>执行结果为：</strong></p>



<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">Array</span>
(
    [<span class="hljs-number">5</span>] =&gt; mysql
    [<span class="hljs-number">4</span>] =&gt; database
    [<span class="hljs-number">3</span>] =&gt; apache
    [<span class="hljs-number">2</span>] =&gt; webserver
    [<span class="hljs-number">1</span>] =&gt; linux
    [<span class="hljs-number">0</span>] =&gt; os
)</code></pre>

<blockquote>
  <p><strong>count()</strong></p>
</blockquote>

<p>该函数统计数组中的元素数目以及唯一值的个数，对于数组返回返回其中元素值的个数，对于其他值则返回1，若参数未定义或者参数为空值，该函数返回0。第一个参数是必需的，为一个数组或对象，第二个参数可选，判定是否递归的检测数组中数组的元素个数，0为默认值，不检测。</p>

<blockquote>
  <p><strong>array_count_values()</strong></p>
</blockquote>

<p>该函数用于统计数组中所有值出现的次数，参数输入一个数组，返回一个数组，其元素的键名是原数组的值，键值是该该值在原数组中出现的次数。</p>

<blockquote>
  <p><strong>array_unique()</strong></p>
</blockquote>

<p>该函数用于删除数组中重复的值，并返回没有重复值的新数组，参数需要接收一个数组，当数组中几个元素值相等时，只保留<strong>第一个</strong>元素，其他的元素被删除，并且返回新数组的键名不变(数字索引对应的键值同样会保持不变，删除之后，数字索引的键名会不连续。</p>

<blockquote>
  <p><strong>array_filter()</strong></p>
</blockquote>

<p>该函数使用回调函数过滤数组中的元素，返回按照用户自定义函数过滤后的新数组，该函数有两个参数，第一个参数为数组，第二个参数为用户自定义的过滤函数，用户自定义函数的返回值只有true or false，以此用来判断是否进行过滤，如果自定义函数返回true则进行保留该元素。如下例：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$a</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span><span class="hljs-params">(<span class="hljs-variable">$var</span>)</span>{</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$var</span>%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }

    print_r(array_filter(<span class="hljs-variable">$a</span>, <span class="hljs-string">"myFun"</span>));
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>执行结果如下：</p>



<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">Array</span>
(
    [<span class="hljs-number">1</span>] =&gt; <span class="hljs-number">2</span>
    [<span class="hljs-number">3</span>] =&gt; <span class="hljs-number">4</span>
    [<span class="hljs-number">5</span>] =&gt; <span class="hljs-number">6</span>
    [<span class="hljs-number">7</span>] =&gt; <span class="hljs-number">8</span>
)</code></pre>

<p>该段代码是利用array_filter函数过滤数组中的元素，过滤函数保留的是能够被2整除的数。过滤之后得到的元素与其对应的数字索引保持不变。</p>

<blockquote>
  <p><strong>array_walk()</strong></p>
</blockquote>

<p>该函数对数组中的<strong>每个元素</strong>都会调用回调函数进行处理，成功返回true，否则返回false。自定义函数有两个必须参数，第一个参数接收传入的元素的值，第二个参数接收传入的元素的键名，第三个为可选参数，如果有定义第三个参数，第三个参数也会被自定义函数接收。如下例：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$a</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span><span class="hljs-params">(<span class="hljs-variable">$var</span>, <span class="hljs-variable">$key</span>)</span>{</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$var</span>%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">echo</span> <span class="hljs-string">"No.$key is two $var\n"</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">echo</span> <span class="hljs-string">"No.$key is one $var\n"</span>;
        }
    }

    array_walk(<span class="hljs-variable">$a</span>, <span class="hljs-string">"myFUn"</span>);
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>执行结果：</p>



<pre class="prettyprint"><code class=" hljs cs">No<span class="hljs-number">.0</span> <span class="hljs-keyword">is</span> two <span class="hljs-number">0</span>
No<span class="hljs-number">.1</span> <span class="hljs-keyword">is</span> one <span class="hljs-number">1</span>
No<span class="hljs-number">.2</span> <span class="hljs-keyword">is</span> two <span class="hljs-number">2</span>
No<span class="hljs-number">.3</span> <span class="hljs-keyword">is</span> one <span class="hljs-number">3</span>
No<span class="hljs-number">.4</span> <span class="hljs-keyword">is</span> two <span class="hljs-number">4</span>
No<span class="hljs-number">.5</span> <span class="hljs-keyword">is</span> one <span class="hljs-number">5</span>
No<span class="hljs-number">.6</span> <span class="hljs-keyword">is</span> two <span class="hljs-number">6</span>
No<span class="hljs-number">.7</span> <span class="hljs-keyword">is</span> one <span class="hljs-number">7</span></code></pre>

<p>这段代码使用array_walk函数将每个元素的值和键名传入回调函数进行处理判断，并输出结果。</p>

<blockquote>
  <p>array_map()</p>
</blockquote>

<p>该函数调用回调函数时一次性处理多个数组，在多个数组之间进行判断。array_map()函数第一个参数为调用的回函数名称，第二个参数为要进行处理的数组，后面的数组为可选参数。实例如下：</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
    <span class="hljs-variable">$a</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);
    <span class="hljs-variable">$b</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span><span class="hljs-params">(<span class="hljs-variable">$var</span>, <span class="hljs-variable">$var1</span>)</span>{</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$var</span> == <span class="hljs-variable">$var1</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-string">"same"</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"different"</span>;
        }
    }

    print_r(array_map(<span class="hljs-string">"myFun"</span>, <span class="hljs-variable">$a</span>, <span class="hljs-variable">$b</span>));
<span class="hljs-preprocessor">?&gt;</span></span></code></pre>

<p>执行结果如下：</p>



<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">Array</span>
(
    [<span class="hljs-number">0</span>] =&gt; different
    [<span class="hljs-number">1</span>] =&gt; different
    [<span class="hljs-number">2</span>] =&gt; same
    [<span class="hljs-number">3</span>] =&gt; same
    [<span class="hljs-number">4</span>] =&gt; different
    [<span class="hljs-number">5</span>] =&gt; different
    [<span class="hljs-number">6</span>] =&gt; different
    [<span class="hljs-number">7</span>] =&gt; same
)</code></pre>

<p>该函数执行的结果为两个数组进行比较之后的结果，返回值为一个数组，是两个传入的数组元素一一进行比较之后得到的每个元素处理结果组成的数组，若两个数组长度不相同，则会自动在短的数组之后补空进行处理。</p>
            <div>
                作者：zhuxinquan61 发表于2015/11/6 23:18:05 <a href="http://blog.csdn.net/zhuxinquan61/article/details/49401213">原文链接</a>
            </div>
            <div>
            阅读：80 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/49401213#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]利用堆栈实现表达式求值]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/48783279</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/48783279</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/9/28 16:53:30</pubDate>
            <description><![CDATA[
            <blockquote>
  <p><strong>栈</strong>（stack）又名<a href="http://baike.baidu.com/link?url=lhbFuYtck8D6CUTM_fPfVBxo7-3j4Up19yFWqTPc7logRZrYXGOZy6jHl22KKAf9kfZsGSZrTSsku0dCf7Phdd2MCRJSQ0FNS2zw8Bw9Kfm">堆栈</a>，它是一种运算受限的线性表。</p>
</blockquote>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈的限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们正是利用栈的这种特性来实现表达式求值，这里我要说的是中缀表达式求值。对于表达式求值的运算需要注意的一大问题就是运算优先级的比较，我们利用两个栈将操作数和运算符分开存放，当第一次遇到数字时我们将其压入栈低然后继续向后获取表达式的值，当遇到第一个符号时我们也将其压入栈低，不过在符号栈的初始化的过程中，我们应当首先向其中存入一个参考的符号 ‘#’ ,这个符号的总用是判断符号栈是否为空，这样做是因为我们输入的表达式的最后也会有这样一个字符 ‘#’ ,当两个 ‘#’相遇的时候则说明该表达式计算结束。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是表达式计算的问题，当我们从表达式中取到的运算符比运算符栈顶的运算符优先级低的时候，则将栈定运算符取出，并取出两个操作数进行运算，当运算完成之后，再将运算结果写回栈定。</p>

<p>总的说来，就是首先比较两个运算符的优先级，然后根据优先级来决定是进行计算还是存入栈中。当然我们首先要进行优先级的比较。</p>

<blockquote>
  <p><strong>优先级比较</strong></p>
</blockquote>

<p>我们将所有的运算符的比较结果存入一个二维数组，当我们需要比较两个运算符优先级高低的时候，我们只需要得到该二维数组对应的元素即可。比较结果如下表：</p>

<pre><code>    {'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;'},

    {'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;'},

    {'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;'},

    {'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;'},

    {'&lt;','&lt;','&lt;','&lt;','&lt;','=','0'},

    {'&gt;','&gt;','&gt;','&gt;','0','&gt;','&gt;'},

    {'&lt;','&lt;','&lt;','&lt;','&lt;','0','='},
</code></pre>

<p>7行7列分别代表的是+、-、<em>、/、（、）、# 这些运算符，对于相同的运算符相遇+、-、</em>、/ 默认前面的优先级高于后面的运算符，当两个左括号相遇则前括号优先级小于后括号，就相当于内部的括号。当两个右括号相遇，前括号优先级高于后括号。当两个#相遇说明计算已完成，当左右括号相遇则视之为相等，直接去括号即可，其余为’0’的情况是不可能出现的情况，即输入表达式错误。 <br>
具体计算过程涉及到出栈、入栈、得到栈顶元素、以及计算两个运算数的结果，下面是各部分的代码：</p>

<blockquote>
  <p>取得栈定元素</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> get_stack(StackType * top, <span class="hljs-keyword">int</span> * <span class="hljs-keyword">x</span>)
{
    <span class="hljs-keyword">if</span>(top-&gt;<span class="hljs-keyword">next</span> == NULL)
    {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-variable">*x</span> = top-&gt;<span class="hljs-keyword">next</span>-&gt;data;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>表达式求值</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> EvaluateExpression()
{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">int</span> c;                                  <span class="hljs-comment">//存储输入缓存中的字符或数字</span>
    <span class="hljs-keyword">int</span> flag;                               <span class="hljs-comment">//从输入缓存中取操作符的返回值，0表示取出数字，1表示取出运算符</span>
    <span class="hljs-keyword">int</span> x;                                  <span class="hljs-comment">//取栈顶操作符</span>
    <span class="hljs-keyword">int</span> operate;                            <span class="hljs-comment">//存储要计算的操作符</span>
    <span class="hljs-keyword">int</span> a, b;                               <span class="hljs-comment">//存取要计算的操作数</span>
    StackType * top_oprd, * top_optr;       <span class="hljs-comment">//top_oprd为操作数栈，top_optr为运算符栈</span>

    <span class="hljs-keyword">char</span> op[] = <span class="hljs-string">"+-*/()#"</span>;

    top_oprd = Init_stack();
    top_optr = Init_stack();

    Push_stack(top_optr, <span class="hljs-string">'#'</span>);
    flag = getnext(&amp;c);

    get_stack(top_optr, &amp;x);
    <span class="hljs-keyword">while</span>(c != <span class="hljs-string">'#'</span> || x != <span class="hljs-string">'#'</span>)         <span class="hljs-comment">//表达式的起始位置都是'#'，如果读取的新的字符和运算符都是'#'说明运算已经结束</span>
    {
        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)                   <span class="hljs-comment">//返回数字</span>
        {
            Push_stack(top_oprd, c);
            flag = getnext(&amp;c);
        }
        <span class="hljs-keyword">else</span>                            <span class="hljs-comment">//返回运算符</span>
        {
            get_stack(top_optr, &amp;x);        <span class="hljs-comment">//取栈顶运算符</span>
            <span class="hljs-keyword">switch</span>(compare(x, c))
            {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:               <span class="hljs-comment">//栈顶操作符运算优先级低</span>
                Push_stack(top_optr, c);
                flag = getnext(&amp;c);
                <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:               <span class="hljs-comment">//栈顶运算符优先级高,先退出两个数据进行运算，然后将运算结果在存入数据栈</span>
                pop_stack(top_optr, &amp;operate);
                pop_stack(top_oprd, &amp;a);
                pop_stack(top_oprd, &amp;b);
                Push_stack(top_oprd, Operation(a, operate, b));
                <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'='</span>:               <span class="hljs-comment">//操作符'('')'紧挨，则直接去除括号</span>
                pop_stack(top_optr, &amp;operate);
                flag = getnext(&amp;c);
                <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>:               <span class="hljs-comment">//比较结果得出表达式错误</span>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"input error!\n"</span>);
            }
        }
        get_stack(top_optr, &amp;x);
    }
    get_stack(top_oprd, &amp;c);
    <span class="hljs-keyword">return</span> c;

}</code></pre>

<blockquote>
  <p>实际计算两个操作数的结果</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> Operation(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> operate, <span class="hljs-keyword">int</span> b)           <span class="hljs-comment">//实际操作两个数a,b的运算</span>
{
    <span class="hljs-keyword">int</span> i, j, result;
    i = a;
    j = b;

    <span class="hljs-keyword">switch</span>(operate){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: result = a + b; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: result = a - b; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: result = a * b; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: result = a / b; <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> result;
}</code></pre>

<blockquote>
  <p>优先级比较函数</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">/*对于连续出现的运算符进行比较优先级
 * 结果有&gt; &lt; =，可以得到+-×/之间的优
 * 先级，加减乘除的优先级都低于'('，
 * 但是都高于')',并且根据从左到右运算
 * 可知当运算符相同时，第一个大于第二
 * 个,0表示不存在
 * */</span>

<span class="hljs-keyword">char</span> compare(<span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b)
{
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">char</span> pre[<span class="hljs-number">7</span>][<span class="hljs-number">7</span>] ={                       <span class="hljs-comment">//定义运算符之间的优先级</span>
        {<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
        {<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
        {<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
        {<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
        {<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'='</span>,<span class="hljs-string">'0'</span>},
        {<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
        {<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'='</span>},
    };
    <span class="hljs-keyword">switch</span>(a){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: i = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: i = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: i = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: i = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: i = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>: i = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>: i = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">switch</span>(b){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: j = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: j = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: j = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: j = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: j = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>: j = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>: j = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> pre[i][j];
}</code></pre>

<blockquote>
  <p>取表达式中下一个操作元素（数或运算符）</p>
</blockquote>

<p>在这部分使用到了<strong>ungetc()</strong>函数，该函数是将刚读出的字符串重新写回输入缓存当中等待下一次读取。在此处的作用：当读到第一个字符为数字时继续向下一个读取，将连起来的数字符组成一个十进制数，但是这样势必会读到数字之后的一个字符，当读到该字符时结束，并将该非数字字符写回输入缓冲区中，等待下一次读取。</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> getnext(<span class="hljs-keyword">int</span> * n)                        <span class="hljs-comment">//该函数返回0为数字，返回1为运算符</span>
{
    <span class="hljs-keyword">char</span> c;
    *n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>((c = getchar()) == <span class="hljs-string">' '</span>);          <span class="hljs-comment">//跳过空格</span>
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(c)){                        <span class="hljs-comment">//判断是否是数字</span>
        *n = c;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">do</span>{
        *n = *n * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);           <span class="hljs-comment">//使用循环获得连续的数字，乘10进位</span>
        c = getchar();
    }<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c));
    ungetc(c, stdin);                       <span class="hljs-comment">//读到一个运算符，将运算符写回输入缓存</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>元素出栈</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> pop_stack(StackType * top, <span class="hljs-keyword">int</span> * <span class="hljs-keyword">x</span>)
{
    StackType * p;
    <span class="hljs-keyword">if</span>(top-&gt;<span class="hljs-keyword">next</span> == NULL){
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    p = top-&gt;<span class="hljs-keyword">next</span>;
    top-&gt;<span class="hljs-keyword">next</span> = p-&gt;<span class="hljs-keyword">next</span>;
    <span class="hljs-variable">*x</span> = p-&gt;data;
    free(p);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>元素入栈</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs lasso">int Push_stack(StackType <span class="hljs-subst">*</span> top, int x)
{
    StackType <span class="hljs-subst">*</span> p;
    p <span class="hljs-subst">=</span> (StackType <span class="hljs-subst">*</span>)malloc(sizeof(StackType));
    <span class="hljs-keyword">if</span>(p <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
    }
    p<span class="hljs-subst">-&gt;</span><span class="hljs-built_in">data</span> <span class="hljs-subst">=</span> x;
    p<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> top<span class="hljs-subst">-&gt;</span>next;
    top<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> p;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
}</code></pre>

<blockquote>
  <p>栈的初始化</p>
</blockquote>

<pre class="prettyprint"><code class=" hljs objectivec">StackType * Init_stack()
{
    StackType * top;
    top = (StackType *)malloc(<span class="hljs-keyword">sizeof</span>(StackType));
    top-&gt;next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> top;
}</code></pre>

<p>详细的实现代码可以查看<a href="https://github.com/zhuxinquan/Data-Structure-And-Algorithm/blob/master/Stack_And_Queue/3.1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.c" target="_blank&quot;">这里</a>.</p>
            <div>
                作者：zhuxinquan61 发表于2015/9/28 16:53:30 <a href="http://blog.csdn.net/zhuxinquan61/article/details/48783279">原文链接</a>
            </div>
            <div>
            阅读：1151 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/48783279#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]Josephus问题分析与实现]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/48715343</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/48715343</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/9/24 22:29:10</pubDate>
            <description><![CDATA[
            <blockquote>
  <p><strong>Josephus问题</strong>：编号为1，2，3，……n的n个人按顺时针方向围坐在一张圆桌周围，每人持有一个密码（正整数）。任选一个正整数作为报数上限值值m，从第一个人开始按顺时针方向自1开始报数，报到m的人出列，并将他的密码作为新的密码，重新从1开始报数，依次出列，直至所有人全部出列为止！</p>
</blockquote>

<p><strong>问题分析：</strong></p>

<p>围成一圆桌的人可以认为是一个循环链表，每个链表节点有两个数据成员，一个是成员本身的序号，另一个是这个成员本身的密码。结构体的定义如下：</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> NodeType
{
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">id</span>;                   <span class="hljs-comment">//成员本身序号</span>
    <span class="hljs-keyword">int</span> password;             <span class="hljs-comment">//成员持有的密码</span>
    <span class="hljs-keyword">struct</span> NodeType *next;
}NodeType;</code></pre>



<h4 id="创建循环链表的代码如下">创建循环链表的代码如下：</h4>



<pre class="prettyprint"><code class=" hljs perl">void CreatList(NodeType <span class="hljs-variable">**</span>phead, <span class="hljs-keyword">int</span> n)
{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> ipassword = <span class="hljs-number">0</span>;
    NodeType <span class="hljs-variable">*pnew</span> = NULL;
    NodeType <span class="hljs-variable">*pcur</span> = NULL;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    {
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"请输入第<span class="hljs-variable">%d</span>个人的密码："</span>, i);
        scanf(<span class="hljs-string">"<span class="hljs-variable">%d</span>"</span>, &amp;ipassword);
        pnew = GetNode(i, ipassword);
        <span class="hljs-keyword">if</span>(<span class="hljs-variable">*phead</span> == NULL)
        {
            <span class="hljs-variable">*phead</span> = pcur = pnew;
            pcur-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-variable">*phead</span>;
        }
        <span class="hljs-keyword">else</span>{
            pnew-&gt;<span class="hljs-keyword">next</span> = pcur-&gt;<span class="hljs-keyword">next</span>;
            pcur-&gt;<span class="hljs-keyword">next</span> = pnew;
            pcur = pnew;
        }
    }
    <span class="hljs-keyword">printf</span>(<span class="hljs-string">"单向链表创建完成！\n"</span>);
}
/<span class="hljs-variable">*创</span>建一个节点<span class="hljs-variable">*/</span>
NodeType <span class="hljs-variable">*GetNode</span>(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> ipassword)
{
    NodeType <span class="hljs-variable">*pnew</span> = NULL;
    pnew = (NodeType <span class="hljs-variable">*)</span>malloc(sizeof(NodeType));
    <span class="hljs-keyword">if</span>(!pnew)
    {
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"malloc error!\n"</span>);
        <span class="hljs-keyword">exit</span>(-<span class="hljs-number">1</span>);
    }
    pnew-&gt;id = id;
    pnew-&gt;password = ipassword;
    pnew-&gt;<span class="hljs-keyword">next</span> = NULL;
    <span class="hljs-keyword">return</span> pnew;
}</code></pre>

<p>创建循环链表使用尾差法，CreatList函数中，实参pphead为二级指针，使用二级指针是因为在main函数（后面可以看到）中已经定义好了phead，如果传参数为phead，则在创建完成之后，链表的头指针往后的节点都在实参所申请的内存空间当中，即就是实参会将形参的内容进行复制，但同时也会创建一个新的地址空间，并将后面创建的节点连接在新的地址空间之后，所以当函数返回，虽然循环链表已经生成，但是phead并没有将后面的节点连接在它后面（也就是phead依旧会是空的）。</p>



<h4 id="原始循环链表的打印">原始循环链表的打印：</h4>

<p>将原始的循环链表按照存放的顺序进行输出，需要注意的是，循环链表的结尾，所以循环链表的输出结束条件应当是当前输出的项不是第一项（可使用do……while循环先将第一项进行输出）。代码如下：</p>



<pre class="prettyprint"><code class=" hljs perl">void Print_List(NodeType <span class="hljs-variable">*phead</span>)
{
    NodeType <span class="hljs-variable">*pcur</span> = phead;
    <span class="hljs-keyword">if</span>(!IsEmptyList(phead))
    {
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"id       password\n"</span>);
        <span class="hljs-keyword">do</span>{
            <span class="hljs-keyword">printf</span>(<span class="hljs-string">"<span class="hljs-variable">%3d</span>, <span class="hljs-variable">%7d</span>\n"</span>, pcur-&gt;id, pcur-&gt;password);
            pcur = pcur-&gt;<span class="hljs-keyword">next</span>;
        }<span class="hljs-keyword">while</span>(pcur != phead);
    }
}</code></pre>



<h4 id="判空操作">判空操作：</h4>

<p>当每次出列一个人之后，链表就会缩短，使用该函数来判断是否为空链表：</p>



<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> IsEmptyList(NodeType <span class="hljs-variable">*phead</span>)
{
    <span class="hljs-keyword">if</span>(!phead)
    {
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"the list is empty!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<h4 id="约瑟夫环操作"><strong>约瑟夫环操作：</strong></h4>

<p>要实现约瑟夫环，就必定需要删除链表节点，要删除链表节点，就需要有删除节点的前驱节点，对于该循环链表，由于创建时没有表头节点，所以首先需要通过一个循环将prv指针移到链表的末尾，然后prv-&gt;next即就是head节点的前驱。之后需要通过一个次数为密码的循环，将prv和pcur同时后移密码数个节点，在这个循环中应当添加一个条件，当prv和pcur相同时说明链表仅剩一个元素，这时可以做一个标志位，退出循环，在删除该节点前，应当先输出该节点，删除时也要注意先将密码进行更新，也就是将要删除的节点保存到循环的次数中。该部分代码实现如下：</p>



<pre class="prettyprint"><code class=" hljs perl">void JosephusOperate(NodeType <span class="hljs-variable">**</span>phead, <span class="hljs-keyword">int</span> ipassword)
{
    <span class="hljs-keyword">int</span> icount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> iflag = <span class="hljs-number">1</span>;
    NodeType * prv = NULL;
    NodeType * pcur = NULL;
    NodeType * pdel = NULL;
    prv = pcur = <span class="hljs-variable">*phead</span>;
    <span class="hljs-keyword">while</span>(prv-&gt;<span class="hljs-keyword">next</span> != <span class="hljs-variable">*phead</span>)
    {
        prv = prv-&gt;<span class="hljs-keyword">next</span>;
    }
    <span class="hljs-keyword">while</span>(iflag)
    {
        <span class="hljs-keyword">for</span>(icount = <span class="hljs-number">1</span>; icount &lt; ipassword; icount++)
        {
            prv = pcur;
            pcur = pcur-&gt;<span class="hljs-keyword">next</span>;
        }
        <span class="hljs-keyword">if</span>(prv == pcur)
        {
            iflag = <span class="hljs-number">0</span>;
        }
        pdel = pcur;
        prv-&gt;<span class="hljs-keyword">next</span> = pcur-&gt;<span class="hljs-keyword">next</span>;
        pcur = pcur-&gt;<span class="hljs-keyword">next</span>;
        ipassword = pdel-&gt;password;
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"第<span class="hljs-variable">%d</span>个人出列（密码：<span class="hljs-variable">%d</span>）\n"</span>, pdel-&gt;id, pdel-&gt;password);
        free(pdel);
    }
    <span class="hljs-variable">*phead</span> = NULL;
    getchar();
}</code></pre>

<p>以上是我对约瑟夫环的理解，完整的代码可以参考<a href="https://github.com/zhuxinquan/Data-Structure-And-Algorithm/blob/master/JosephusOperate.c" target="_blank">这里</a>.</p>



<h4 id="上面是一个带密码的约瑟夫环问题还有一个比较简单的不带密码的相比来说更加简单只是每次的密码都固定也就是循环的次数是固定不变的在程序运行开始就预先输入了人数和密码完整代码可以参考这里">上面是一个带密码的约瑟夫环问题，还有一个比较简单的不带密码的，相比来说更加简单，只是每次的密码都固定，也就是循环的次数是固定不变的，在程序运行开始，就预先输入了人数和密码，完整代码可以参考<a href="https://github.com/zhuxinquan/Data-Structure-And-Algorithm/blob/master/josephus_sort.c" target="_blank">这里</a>.</h4>
            <div>
                作者：zhuxinquan61 发表于2015/9/24 22:29:10 <a href="http://blog.csdn.net/zhuxinquan61/article/details/48715343">原文链接</a>
            </div>
            <div>
            阅读：77 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/48715343#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]简单的client/server模型]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47728975</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47728975</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/8/24 16:43:18</pubDate>
            <description><![CDATA[
            <p>所谓<strong>client/server</strong>简单来说就是客户端服务器模型，简称C/S模型，一个简单的CS模型所用到的只是一些简单的网络方面的知识，下面我以一个面向连接的CS实例来解释面向连接的主要过程： <br>
首先我们想看一张图，来了解一下服务器端和客户端的链接过程： <br>
<img src="http://img.blog.csdn.net/20150824154857549" alt="这里写图片描述" title=""> <br>
首先是服务器端，服务器首先要创建套接字，然后将其绑定到本地端口，之后将其转换为链接套接字，之后就时阻塞等待客户端的连接了。</p>

<p>在这里解释一下<strong>端口和IP地址</strong>之间的关系：我们都知道IP地址就如同家庭的地址和门牌号，能够找到某人的家，这里就如同找到某台主机是一样的，但是家里的人不止一个，就如同一台主机同时运行的应用程序有好多一样，要将消息准发到特定的应用程序就需要用到端口号，端口号就是该应用程序消息的接口。一般情况下，某个应用程序的端口是特定的，例如：浏览器的端口是80一样。 <br>
那么套接字又是干什么的呢？套接字中保存有客户端课服务器端的IP地址和连接套接字，有了连接套接字就能将信息发出了。</p>

<p>客户端同时也需要建立一个连接套接字，在客户端将IP地址和端口等信息初始化完成之后，就需要将客户端与服务器连接，此时服务器处于阻塞状态等待客户端的连接，当客户端连接成功之后，就会产生一个连接套接字，消息通过连接套接字发送和接收。</p>

<p>上图读取数据和发送数据就是通过send函数和recv函数来实现的。</p>

<p>在服务器和客户端之间一般是发送一些特定的数据包，例如整个结构体数据，我们可以利用memcpy函数将结构体保存在一个字符串数组当中，然后等到在客户端接收之后，再将其还原为一个结构体。</p>

<p>下面是实例的代码： <br>
<strong>客户端</strong>：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include "my_recv.h"</span>

<span class="hljs-preprocessor">#define INVALID_USERINFO    'n'     <span class="hljs-comment">//用户信息无效</span></span>
<span class="hljs-preprocessor">#define VALID_USERINFO      'y'     <span class="hljs-comment">//用户信息有效</span></span>

<span class="hljs-keyword">int</span> get_userinfo(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">int</span> len)                <span class="hljs-comment">//获取用户输入存入buf，长度len，以'\n'结束</span>
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> c;

    <span class="hljs-keyword">if</span>(buf == NULL)
    {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(((c = getchar()) != <span class="hljs-string">'\n'</span>) &amp;&amp; (c != EOF) &amp;&amp; (i &lt; len - <span class="hljs-number">2</span>))
    {
        buf[i++] = c;
    }
    buf[i++] = <span class="hljs-string">'\n'</span>;
    buf[i++] = <span class="hljs-string">'\0'</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}


<span class="hljs-keyword">void</span> input_userinfo(<span class="hljs-keyword">int</span> conn_fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-built_in">string</span>)                <span class="hljs-comment">//输入用户名，然后通过fd发送出去</span>
{
    <span class="hljs-keyword">char</span> input_buf[<span class="hljs-number">32</span>];
    <span class="hljs-keyword">char</span> recv_buf[BUFSIZE];
    <span class="hljs-keyword">int</span>  flag_userinfo;

    <span class="hljs-keyword">do</span>
    {                                                             <span class="hljs-comment">//输入用户信息知道正确为止 </span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s:"</span>, <span class="hljs-built_in">string</span>);
        <span class="hljs-keyword">if</span>(get_userinfo(input_buf, <span class="hljs-number">32</span>) &lt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error return from get_userinfo\n"</span>);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">if</span>(send(conn_fd, input_buf,<span class="hljs-built_in">strlen</span>(input_buf), <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)
        {
            my_err(<span class="hljs-string">"send"</span>, __LINE__);
        }

        <span class="hljs-keyword">if</span>(my_recv(conn_fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf)) &lt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"data is too long\n"</span>);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">if</span>(recv_buf[<span class="hljs-number">0</span>] == VALID_USERINFO)
        {
            flag_userinfo = VALID_USERINFO;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s error, input again,"</span>, <span class="hljs-built_in">string</span>);
            flag_userinfo = INVALID_USERINFO;
        }
    }<span class="hljs-keyword">while</span>(flag_userinfo == INVALID_USERINFO);
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)
{
    <span class="hljs-keyword">int</span>                  i;
    <span class="hljs-keyword">int</span>                  ret;
    <span class="hljs-keyword">int</span>                  conn_fd;
    <span class="hljs-keyword">int</span>                  serv_port;
    <span class="hljs-keyword">struct</span> sockaddr_in   serv_addr;
    <span class="hljs-keyword">char</span>                 recv_buf[BUFSIZE];

    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">5</span>)                                   <span class="hljs-comment">//检查参数个数</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"usage : [-p] [serv_port] [-a] [serv_address]\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));        <span class="hljs-comment">//初始化服务器端地址结构</span>
    serv_addr.sin_family = AF_INET;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)                                   <span class="hljs-comment">//从命令行获取服务器的端口与地址</span>
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">"-p"</span>, argv[i]) == <span class="hljs-number">0</span>)
        {
            serv_port = atoi(argv[i+<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">if</span>(serv_port &lt; <span class="hljs-number">0</span> || serv_port &gt; <span class="hljs-number">65535</span>)
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"invalid serv_addr.sin_port\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">else</span>
            {
                serv_addr.sin_port = htons(serv_port);
            }
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">"-a"</span>, argv[i]) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span>(inet_aton(argv[i+<span class="hljs-number">1</span>], &amp;serv_addr.sin_addr) == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"invalid server ip address\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }
    }

    <span class="hljs-keyword">if</span>(serv_addr.sin_port == <span class="hljs-number">0</span> || serv_addr.sin_addr.s_addr == <span class="hljs-number">0</span>)           <span class="hljs-comment">//检测是否少输入了某项参数</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"usage: [-p] [serv_addr.sin_port] [-a] [serv_address]\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    conn_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);                              <span class="hljs-comment">//创建一个tcp套接字</span>
    <span class="hljs-keyword">if</span>(conn_fd &lt; <span class="hljs-number">0</span>){
        my_err(<span class="hljs-string">"socket"</span>, __LINE__);
    }

    <span class="hljs-keyword">if</span>(connect(conn_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) &lt; <span class="hljs-number">0</span>){    <span class="hljs-comment">//向服务器端发送连接请求</span>
        my_err(<span class="hljs-string">"connect"</span>, __LINE__);
    }

    input_userinfo(conn_fd, <span class="hljs-string">"username"</span>);                    <span class="hljs-comment">//输入用户名和密码</span>
    input_userinfo(conn_fd, <span class="hljs-string">"password"</span>);

    <span class="hljs-keyword">if</span>((ret = my_recv(conn_fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf))) &lt; <span class="hljs-number">0</span>){   <span class="hljs-comment">//读取欢迎信息并打印</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"data is too long\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; ret; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, recv_buf[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

    close(conn_fd);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

<p><strong>服务器端：</strong></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include "my_recv.h"</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>

<span class="hljs-preprocessor">#define SERV_PORT       4507        <span class="hljs-comment">//服务器的端口</span></span>
<span class="hljs-preprocessor">#define LISTENQ         12          <span class="hljs-comment">//连接请求队列的最大长度</span></span>

<span class="hljs-preprocessor">#define INVALID_USERINFO    'n'     <span class="hljs-comment">//用户信息无效</span></span>
<span class="hljs-preprocessor">#define VALID_USERINFO      'y'     <span class="hljs-comment">//用户信息有效</span></span>

<span class="hljs-preprocessor">#define USERNAME            0       <span class="hljs-comment">//接受到的是用户名</span></span>
<span class="hljs-preprocessor">#define PASSWORD            1       <span class="hljs-comment">//接受到的是密码</span></span>

<span class="hljs-keyword">struct</span> userinfo                     <span class="hljs-comment">//保存用户名和密码的结构体</span>
{
    <span class="hljs-keyword">char</span> username[<span class="hljs-number">32</span>];
    <span class="hljs-keyword">char</span> password[<span class="hljs-number">32</span>];
};

<span class="hljs-keyword">struct</span> userinfo users[] =
{
    {<span class="hljs-string">"linux"</span>, <span class="hljs-string">"unix"</span>},
    {<span class="hljs-string">"4507"</span>, <span class="hljs-string">"4508"</span>},
    {<span class="hljs-string">"clh"</span>, <span class="hljs-string">"clh"</span>},
    {<span class="hljs-string">"xl"</span>, <span class="hljs-string">"xl"</span>},
    {<span class="hljs-string">" "</span>, <span class="hljs-string">" "</span>}                      <span class="hljs-comment">//以只含一个空格的字符串作为数组的结束标志</span>
};

<span class="hljs-keyword">int</span> find_name(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name)
{
    <span class="hljs-keyword">int</span>  i;

    <span class="hljs-keyword">if</span>(name == NULL)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"in find_name, NULL pointer"</span>);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; users[i].username[<span class="hljs-number">0</span>] != <span class="hljs-string">' '</span>; i++)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(users[i].username, name) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-keyword">void</span> send_data(<span class="hljs-keyword">int</span> conn_fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-built_in">string</span>)
{
    <span class="hljs-keyword">if</span>(send(conn_fd, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>), <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"send"</span>, __LINE__);   <span class="hljs-comment">//my_err函数在my_recv.h中声明            </span>
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span>                  sock_fd, conn_fd;
    <span class="hljs-keyword">int</span>                  optval;
    <span class="hljs-keyword">int</span>                  flag_recv = USERNAME;
    <span class="hljs-keyword">int</span>                  ret;
    <span class="hljs-keyword">int</span>                  name_num;
    pid_t                pid;
    socklen_t            cli_len;
    <span class="hljs-keyword">struct</span> sockaddr_in   cli_addr, serv_addr;
    <span class="hljs-keyword">char</span>                 recv_buf[<span class="hljs-number">128</span>];

    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);          <span class="hljs-comment">//创建一个TCP套接字</span>
    <span class="hljs-keyword">if</span>(sock_fd &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"socket"</span>, __LINE__);
    }

    optval = <span class="hljs-number">1</span>;                                         <span class="hljs-comment">//设置该套接字使之可以重新绑定端口</span>
    <span class="hljs-keyword">if</span>(setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, (<span class="hljs-keyword">void</span> *)&amp;optval, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"setsocketopt"</span>, __LINE__);
    }

    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));   <span class="hljs-comment">//初始化服务器端地址结构</span>
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERV_PORT);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    <span class="hljs-keyword">if</span>(bind(sock_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in)) &lt; <span class="hljs-number">0</span>)                        <span class="hljs-comment">//将套接字绑定到本地端口</span>
    {
        my_err(<span class="hljs-string">"bind"</span>, __LINE__);
    }

    <span class="hljs-keyword">if</span>(listen(sock_fd, LISTENQ) &lt; <span class="hljs-number">0</span>)                    <span class="hljs-comment">//将套接字转化为监听套接字</span>
    {
        my_err(<span class="hljs-string">"listen"</span>, __LINE__);
    }

    cli_len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        conn_fd = accept(sock_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr, &amp;cli_len);
        <span class="hljs-keyword">if</span>(conn_fd &lt; <span class="hljs-number">0</span>)
        {
            my_err(<span class="hljs-string">"accept"</span>, __LINE__);
        }

        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"accept a new client, ip: %s\n"</span>, inet_ntoa(cli_addr.sin_addr));
        <span class="hljs-keyword">if</span>((pid = fork()) == <span class="hljs-number">0</span>)                         <span class="hljs-comment">//创建子进程处理刚刚接收的连接请求</span>
        {
            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)                                    <span class="hljs-comment">//子进程</span>
            {
                <span class="hljs-keyword">if</span>((ret = recv(conn_fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf), <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)
                {
                    perror(<span class="hljs-string">"recv"</span>);
                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
                }
                recv_buf[ret - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;               <span class="hljs-comment">//将数据结束标志'\n'替换成字符串结束标志</span>

                <span class="hljs-keyword">if</span>(flag_recv == USERNAME)               <span class="hljs-comment">//接收到的是用户名</span>
                {
                    name_num = find_name(recv_buf);
                    <span class="hljs-keyword">switch</span> (name_num)
                    {
                        <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:
                            send_data(conn_fd, <span class="hljs-string">"n\n"</span>);
                            <span class="hljs-keyword">break</span>;
                        <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:
                            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
                            <span class="hljs-keyword">break</span>;
                        <span class="hljs-keyword">default</span>:
                            send_data(conn_fd, <span class="hljs-string">"y\n"</span>);
                            flag_recv = PASSWORD;
                            <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag_recv == PASSWORD)          <span class="hljs-comment">//接收到的是密码 </span>
                {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(users[name_num].password, recv_buf) == <span class="hljs-number">0</span>)
                    {
                        send_data(conn_fd, <span class="hljs-string">"y\n"</span>);
                        send_data(conn_fd, <span class="hljs-string">"welcome login my tcp server\n"</span>);
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s login \n"</span>, users[name_num].username);
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        send_data(conn_fd, <span class="hljs-string">"n\n"</span>);
                    }
                }
            }
            close(sock_fd);
            close(sock_fd);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                                    <span class="hljs-comment">//结束子进程            </span>
        }
        <span class="hljs-keyword">else</span>
        {
            close(conn_fd);                             <span class="hljs-comment">//父进程关闭刚刚接收的连接请求，执行accept等待其他连接请求</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>my_recv.h</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#ifndef _MY_RECV_H</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> _MY_RECV_H</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span>
    <span class="hljs-keyword">void</span> my_err(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * err_string, <span class="hljs-keyword">int</span> line);
    <span class="hljs-keyword">int</span> my_recv(<span class="hljs-keyword">int</span> conn_fd, <span class="hljs-keyword">char</span> * data_buf, <span class="hljs-keyword">int</span> len);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span></code></pre>

<p>这里自定义了一个读取数据的函数，实际就是将套接字缓冲区的数据拷贝到自定义缓冲区（以”\n”为结束标志），然后再按格式将数据读出（效果和上面所说的memcpy函数是一样的）。</p>

<p>在该例中，当收到一个新的客户端的连接请求之后，服务器端就会创建一个新的进程来处理客户端的请求。关于进程创建可以参考<a href="http://blog.csdn.net/zhuxinquan61/article/details/47128297">进程控制</a>。</p>

<p>在该客户端，首先创建了一个TCP套接字，然后调用函数connect请求与服务器端连接，建立连接之后，通过连接套接字首先发送用户名，然后等待服务器确认，若用户存在，则发送密码，若密码正确，则返回欢迎页面。</p>

<p>下面是可执行文件的链接地址：<a href="https://github.com/zhuxinquan/linux_c/tree/master/section_11/csmodel">github</a></p>

<p>执行本程序时，首先在某一终端运行服务器端程序，然后在另外几个终端运行客户端。在客户端执行时输入如下数据： <br>
./client -a 127.0.0.1 -p 4507</p>

<p>服务器中默认存在用户，用户名和密码分别是： <br>
   {“linux”, “unix”},   {“4507”, “4508”},   {“clh”, “clh”},   {“xl”, “xl”}。</p>
            <div>
                作者：zhuxinquan61 发表于2015/8/24 16:43:18 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47728975">原文链接</a>
            </div>
            <div>
            阅读：218 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47728975#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]feof与块读写]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47681973</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47681973</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/8/15 15:35:46</pubDate>
            <description><![CDATA[
            <h4 id="feof">feof</h4>

<pre class="prettyprint"><code class=" hljs perl">  <span class="hljs-comment">#include &lt;stdio.h&gt;</span>
  void clearerr(FILE <span class="hljs-variable">*stream</span>);
  <span class="hljs-keyword">int</span> feof(FILE <span class="hljs-variable">*stream</span>);
  <span class="hljs-keyword">int</span> ferror(FILE <span class="hljs-variable">*stream</span>);
  <span class="hljs-keyword">int</span> fileno(FILE <span class="hljs-variable">*stream</span>);</code></pre>

<p>feof是用来判断文件是否到达文件尾的一个函数，当读到一个文件的末尾时返回非零值，若没有到末尾则返回0。</p>

<p>开始觉得挺好理解的，就是用来判断是否到达文件末尾而已，但是到大一期末课设用的时候才发现问题，而且很多人都有同样的问题，当时也想不出所以然，以为是使用块读写惹的祸，于是改用格式化文件输入输出，不知怎么地也就解决了，但是现在要使用块读写时又复现这个问题了，最后才知道原来feof并非。。。</p>

<p>首先，百度百科中有这样一句话来解释位置和内容：“你走到火车的最后一节车箱”这就是位置，而“请你一直向后走，摸到铁轨结束”这就是内容。也就是说用内容来判断会“多走一节”。这就是完全依赖于“while(!feof(FP)){…}”进行文件复制时，目标文档总会比源文档“多出一些”的原因。</p>

<p>说白了就是：当你的文件指针已经读取到最后了，但是feof还是会返回没有到文件的末尾，你再去读一次，读到了一次空的数据，这时用feof判断才会真正的返回非0值，表示文件到达文件尾了。</p>

<p>为了解决这个问题，当我们读取一个块时我们可以这样去写：</p>

<pre class="prettyprint"><code class=" hljs mel"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">fread</span>(void <span class="hljs-variable">*ptr</span>, sze_t <span class="hljs-keyword">size</span>, size_t nmemb, FILE <span class="hljs-variable">*stream</span>) != <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-keyword">feof</span>(fp))
{}</code></pre>

<p>意思就是让它先去读一块，然后判断是否到达文件末尾，如果到达文件末尾，那么刚才读出的那一块内存也是空的，直接丢弃就好了。</p>
            <div>
                作者：zhuxinquan61 发表于2015/8/15 15:35:46 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47681973">原文链接</a>
            </div>
            <div>
            阅读：143 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47681973#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]多线程之互斥锁、条件变量]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47271535</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47271535</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/8/4 16:06:27</pubDate>
            <description><![CDATA[
            <h4 id="多线程"><strong>多线程</strong></h4>

<p>一个进程在同一时刻只能做一件事，而多个线程却可以同时执行，每个线程处理各自独立的任务。多线程有很多好处：</p>

<ul>
<li>简化处理异步事件的代码</li>
<li>实现内存和文件描述符的共享</li>
<li>改善程序的吞吐量</li>
<li>改善响应时间</li>
</ul>



<h4 id="互斥锁"><strong>互斥锁</strong></h4>

<blockquote>
  <p>互斥锁:互斥锁通过锁机制来实现线程间的同步，在同一时刻通常只允许一个关键部分的代码</p>
</blockquote>

<p>当多个线程控制相同的内存时，对于读写操作的时间差距就有可能会导致数据的不同步，下图就很清晰的说明了这种情况： <br>
<img src="http://img.blog.csdn.net/20150804091704252" alt="这里写图片描述" title=""> <br>
对于线程A、B此时对同一块内存进行操作，但是由于操作几乎是同时进行的，假设当线程A读入数据i之后，在对数据 i 自加1的同时线程B将原来内存中的数据 i 读出，然后线程A将自加后的数据再写入内存中，同时线程B对读取到的 i 加1，最后将其写入内存，这个程序原本是想通过两个线程对变量 i 进行两次自加运算最后预想的结果应当是7，最后却得到异常的结果。对于这种<strong>临界变量</strong>操作时就有可能导致意外的结果，因而出现了互斥锁和条件变量来保证数据只被一个线程操作。</p>

<p>下面程序的运行结果也很好的说明了多线程操作同一变量不稳定性：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;errno.h&gt;</span>


<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;      <span class="hljs-comment">//用作要改变的全局变量</span>
pthread_mutex_t mutex;  <span class="hljs-comment">//互斥锁变量</span>

<span class="hljs-keyword">void</span> thread1(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-comment">//pthread_mutex_lock (&amp;mutex); //加锁</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread1 a = %d\n"</span>, a);
    a++;
    <span class="hljs-comment">//pthread_mutex_unlock (&amp;mutex);</span>
}


<span class="hljs-keyword">void</span> thread2(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-comment">//pthread_mutex_lock (&amp;mutex);</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread2 a = %d\n"</span>, a);
    a++;
    <span class="hljs-comment">//pthread_mutex_unlock (&amp;mutex);</span>
}

<span class="hljs-keyword">void</span> thread3(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-comment">//pthread_mutex_lock (&amp;mutex);</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread3 a = %d\n"</span>, a);
    a++;
    <span class="hljs-comment">//pthread_mutex_unlock (&amp;mutex);</span>
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    pthread_t tid1, tid2, tid3;   <span class="hljs-comment">//用于接收线程ID</span>
    <span class="hljs-keyword">int</span>       err;                <span class="hljs-comment">//出错码</span>
    <span class="hljs-keyword">void</span> *    tret;               <span class="hljs-comment">//返回值</span>

    <span class="hljs-comment">//创建三个线程</span>
    pthread_create (&amp;tid1, NULL, (<span class="hljs-keyword">void</span> *)thread1, NULL);
    pthread_create (&amp;tid2, NULL, (<span class="hljs-keyword">void</span> *)thread2, NULL);
    pthread_create (&amp;tid3, NULL, (<span class="hljs-keyword">void</span> *)thread3, NULL);

    <span class="hljs-comment">//等待辅线程结束</span>
    err = pthread_join(tid1, &amp;tret);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"join"</span>);
    }
    err = pthread_join(tid2, &amp;tret);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"join"</span>);
    }
    err = pthread_join(tid3, &amp;tret);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"join"</span>);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"result a: %d\n"</span>, a);   <span class="hljs-comment">//查看最后的结果</span>
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</code></pre>

<p>多次执行结果如下： <br>
<img src="http://img.blog.csdn.net/20150804104842539" alt="这里写图片描述" title=""> <br>
发现几次的执行结果并不相同，本来程序是通过三个线程对同一个全局变量进行3次加1的操作结果应当为0， 1，2，3，由于线程间数据不同步所以导致了这样的结果。</p>

<p>当前我们将程序中各个thread函数中的注释取消之后就会得到这样的结果： <br>
<img src="http://img.blog.csdn.net/20150804095732641" alt="这里写图片描述" title=""> <br>
这里就体现了<strong>互斥锁</strong>来保证线程间数据的同步。</p>

<p>使用互斥锁应当<strong>注意</strong>：</p>

<ol>
<li>使用之前必须进行<strong>初始化</strong></li>
<li><p>加锁时，若锁变量已经被锁住，则当前尝试加锁的线程就会<strong>阻塞</strong>，直到互斥锁被其他线程释放</p>

<blockquote>
  <p>阻塞：指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，CPU不会给线程分配时间片，即线程暂停运行）。</p>
</blockquote></li>
<li><p>调用解锁函数的线程必须是给互斥锁加锁的线程</p></li>
<li>当一个线程试图以另一个线程相反的顺序锁住互斥量的时候，就有可能出现死锁</li>
<li>如果线程试图对一个互斥量加锁两次，那么它自身就会陷入<strong>死锁</strong>状态</li>
</ol>

<blockquote>
  <p>死锁：指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
</blockquote>

<h4 id="条件变量"><strong>条件变量</strong></h4>

<blockquote>
  <p>条件变量：是利用线程间共享的全局变量进行同步的一种机制 <br>
  <strong>使用条件变量要注意：</strong></p>
</blockquote>

<ol>
<li>使用之前要初始化</li>
<li>条件变量通常是在互斥锁的保护下求值，若条件表达式为假，那么线程基于条件变量阻塞。</li>
<li>线程被条件变量阻塞后，可以通过pthread_cond_signal和pthread_cond_broadcast激活，pthread_cond_signal激活按照入队顺序激活一个等待线程，pthread_cond_broadcast则激活所有的等待线程</li>
<li>当一个条件变量不再使用时，需要将其清除，清除函数：pthread_cond_destory,<strong>只有在没有线程等待该条件变量的时候才能清除这个条件变量</strong>，否则返回EBUSY。</li>
<li>调用pthread_cond_wait()前必须有本线程加锁，防止多个线程同时请求pthread_cond_wait()。</li>
</ol>
            <div>
                作者：zhuxinquan61 发表于2015/8/4 16:06:27 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47271535">原文链接</a>
            </div>
            <div>
            阅读：104 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47271535#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]线程清理处理程序]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47251139</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47251139</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/8/3 10:54:38</pubDate>
            <description><![CDATA[
            <h4 id="linux提供了一对函数用于自动释放资源声明如下">linux提供了一对函数用于自动释放资源，声明如下：</h4>



<pre class="prettyprint"><code class=" hljs delphi">  #include &lt;pthread.h&gt;
  void pthread_cleanup_push(void <span class="hljs-comment">(*routine)(void *)</span>, void *arg);
  void pthread_cleanup_pop(int execute);</code></pre>

<ol>
<li>线程可以建立多个清理处理程序，处理程序在栈中记录，所以执行顺序与注册时顺序相反。</li>
<li>只有当线程执行以下动作时才会调用清理函数，调用参数为arg。 <br>
<ul><li>调用pthread_exit时</li>
<li>响应取消请求时</li>
<li>用非零execute参数调用跑thread_cleanup_pop时</li></ul></li>
<li>若excute参数设置为0，清理函数将不会被调用。无论是否调用pthread_cleanup_pop函数都将删除上次pthread_cleanup_push调用建立的清理处理程序。</li>
<li>这一对函数是通过宏来实现的，随意必须成对使用 <br>
下面是一个关于线程清理处理程序的示例：</li>
</ol>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include"apue.h"</span>

<span class="hljs-keyword">void</span> cleanup(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cleanp: %s\n"</span>, (<span class="hljs-keyword">char</span> *)arg);
}

<span class="hljs-keyword">void</span> * thr_fn1(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 1 start\n"</span>);
    pthread_cleanup_push(cleanup, <span class="hljs-string">"thread 1 first handler"</span>);
    pthread_cleanup_push(cleanup, <span class="hljs-string">"thread 1 second handler"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 1 push complete\n"</span>);
    <span class="hljs-keyword">if</span>(arg)
    {
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">void</span>*)<span class="hljs-number">1</span>);
    }
    pthread_cleanup_pop(<span class="hljs-number">0</span>);
    pthread_cleanup_pop(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>);
}

<span class="hljs-keyword">void</span> *thr_fn2(<span class="hljs-keyword">void</span> *arg)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 2 start\n"</span>);
    pthread_cleanup_push(cleanup, <span class="hljs-string">"thread 2 first handler"</span>);
    pthread_cleanup_push(cleanup, <span class="hljs-string">"thread 2 second handler"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 2 push complete\n"</span>);
    <span class="hljs-keyword">if</span>(arg)
    {
        pthread_exit ((<span class="hljs-keyword">void</span>*)<span class="hljs-number">2</span>);
    }
    pthread_cleanup_pop(<span class="hljs-number">0</span>);
    pthread_cleanup_pop(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">void</span> *)<span class="hljs-number">2</span>);
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">int</span> err;
    pthread_t tid1, tid2;
    <span class="hljs-keyword">int</span> tret;
    err = pthread_create(&amp;tid1, NULL, thr_fn1, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        err_quit(<span class="hljs-string">"can't create thread 1: %s\n"</span>, strerror(err));
    }
    err = pthread_create(&amp;tid2, NULL, thr_fn2, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        err_quit(<span class="hljs-string">"can't create thread 2 :%s\n"</span>, strerror(err));
    }
    err = pthread_join(tid1, (<span class="hljs-keyword">void</span> *)&amp;tret);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        err_quit(<span class="hljs-string">"can't join with thread 1: %s\n"</span>, strerror(err));
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 1 exit code %d\n"</span>, (<span class="hljs-keyword">int</span>)tret);
    err = pthread_join(tid2, (<span class="hljs-keyword">void</span> *)&amp;tret);
    <span class="hljs-keyword">if</span>(err != <span class="hljs-number">0</span>)
    {
        err_quit(<span class="hljs-string">"can't join with thread 2: %s\n"</span>, strerror(err));
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread 2 exit code %d\n"</span>, (<span class="hljs-keyword">int</span>)tret);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}</code></pre>

<p>程序的运行结果如下： <br>
<img src="http://img.blog.csdn.net/20150803104948846" alt="这里写图片描述" title=""> <br>
通过结果可以看出两线程都正确的启动和退出了，但只调用了第二个线程的清理处理程序，所以如果线程是通过它的<strong>启动例程</strong>中返回而终止，则不会调用清理处理程序。</p>

<blockquote>
  <p>启动例程：调用其他线程的父进程称之为启动例程，也可认为是第一个执行的线程。</p>
</blockquote>

<p>则在本例中main函数为启动例程，在thr_fn1函数中虽然也使用了调用了线程清理处理程序，但是由于中间是通过return返回到启动例程当中，所以线程清理处理程序并未执行。而在thr_fn2函数中使用的是pthread_exit退出的，满足调用线程清理处理函数的条件，因而被执行。同时通过执行结果的倒数二三行，可以看出 pthread_cleanup_push的<strong>注册顺序</strong>与最后的<strong>执行顺序是相反</strong>的。</p>
            <div>
                作者：zhuxinquan61 发表于2015/8/3 10:54:38 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47251139">原文链接</a>
            </div>
            <div>
            阅读：127 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47251139#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]实现自己的myshell]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47183619</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47183619</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/8/1 15:11:21</pubDate>
            <description><![CDATA[
            <blockquote>
  <p>在linux环境下，编写自己的shell</p>
</blockquote>



<h3 id="1要求">1.要求：</h3>

<ol>
<li>实现单个命令，如: ls.</li>
<li>命令可以带参数，如：ls -l /tmp</li>
<li>可以带有一个输入或者输出的重定向。</li>
<li>可以带一个管道符命令</li>
<li>可以后台运行</li>
<li>输入exit或logout退出。</li>
</ol>

<h3 id="2错误处理">2.错误处理：</h3>

<ul>
<li>输入错误的命令格式报错</li>
<li>输入不存在的命令报错</li>
</ul>

<h3 id="3关键函数功能">3.关键函数功能：</h3>

<p><strong>1. 打印myshell前标（print_prompt）：</strong> <br>
     模仿shell中打印<strong>当前目录</strong>的前标。 <br>
 <strong>2. 获取用户的输入（get_input）:</strong> <br>
     获得一条用户输入的命令，将参数包括中间的空格整体存入一个一位数组buf当中，等待下一个函数进行参数解析，并判断如果参数长度若大于256则终止程序，输入的命令以<strong>‘\n’</strong>为结束标志。 <br>
 <strong>3. 参数解析函数（explain_input）：</strong> <br>
     将get_input函数中得到的命令整体传入参数解析函数，并向该函数中传入一个二位字符数组的地址用来保存解析出来的命令，需要注意的是该二位数组的内存空间应当是在主函数中已经开辟好的。 <br>
     <strong>注意：</strong>由于参数解析是通过<strong>空格</strong>将命令和参数以及输入输出重定向等命令、参数分开的，所以当遇上带有空格的目录时，参数解析的时候空格会将一个目录名分开，将其解析为两个参数，所以我们可以模仿shell的办法如下图： <br>
     <img src="http://img.blog.csdn.net/20150801124753862" alt="这里写图片描述" title=""> <br>
     shell的办法是将空格进行转义，所以我们也可以去模仿它，在输入目录的空格之前先输入一个 <strong>‘\’</strong> ,然后输入空格，于是在参数解析时当遇到 <strong>‘\’</strong>的时候我们将其之后的空格跳过之后就可以了，但是在测试chdir函数时又发现了问题，当把带有 <strong>\  </strong>的目录名当做chdir函数的参数改变当前目录的时候会发现报错：该目录不存在，原来<strong>‘\  ‘</strong>只是shell终端的转义，在目录名中并不需要进行转义，只要按原有的格式直接输入就好，所以我们要做的不只是将 \ 后的空格保留，还要将空格之后的所有字符前移并将 \  覆盖掉。具体代码实现如下：</p>

<pre class="prettyprint"><code class=" hljs perl">   <span class="hljs-keyword">if</span>(<span class="hljs-string">q[0]</span> == <span class="hljs-number">92</span>)   //当遇上 \
   {
     <span class="hljs-string">q[0]</span> = <span class="hljs-string">' '</span>;     <span class="hljs-regexp">//</span>用空格将之前的 \ 覆盖
     <span class="hljs-string">q[1]</span> = <span class="hljs-string">q[2]</span>;    <span class="hljs-regexp">//</span>与下面的循环一起，将之后的所有字符前移一位
     <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; ; i++)
     {
         <span class="hljs-string">q[i]</span> = <span class="hljs-string">q[i+1]</span>;
         <span class="hljs-keyword">if</span>((<span class="hljs-string">q[i]</span> == <span class="hljs-string">' '</span>) || (<span class="hljs-string">q[i]</span> == <span class="hljs-string">'\n'</span>)) //如果当前要前移的参数正好是空格或者是<span class="hljs-string">'\n'</span>则结束
         <span class="hljs-keyword">break</span>;
     }
   }</code></pre>

<p><strong>4. 执行命令函数（do_cmd）：</strong> <br>
前面参数解析函数已将解析好的参数存入二维数组当中，这个函数将执行命令，参数argcount记录了命令所带的参数的个数。 <br>
<strong>5.命令查找函数（find_command）：</strong> <br>
在当前目录，/bin，/usr/bin 目录下查找命令的可执行程序 <br>
下面附上代码：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/wait.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;dirent.h&gt;</span>

<span class="hljs-preprocessor">#define normal  0   <span class="hljs-comment">//一般的命令</span></span>
<span class="hljs-preprocessor">#define out_readirect   1   <span class="hljs-comment">//输出重定向</span></span>
<span class="hljs-preprocessor">#define in_readdirect 2     <span class="hljs-comment">//输入重定向</span></span>
<span class="hljs-preprocessor">#define have_pipe   3   <span class="hljs-comment">//命令中有管道</span></span>

<span class="hljs-keyword">void</span> print_prompt();    <span class="hljs-comment">//打印提示符</span>
<span class="hljs-keyword">void</span> get_input(<span class="hljs-keyword">char</span> *);     <span class="hljs-comment">//得到输入的命令</span>
<span class="hljs-keyword">void</span> explain_input(<span class="hljs-keyword">char</span> *, <span class="hljs-keyword">int</span> *, <span class="hljs-keyword">char</span> (*)[<span class="hljs-number">256</span>]);  <span class="hljs-comment">//对输入的命令进行解析</span>
<span class="hljs-keyword">void</span> do_cmd(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> (*)[<span class="hljs-number">256</span>]);   <span class="hljs-comment">//执行命令</span>
<span class="hljs-keyword">int</span> find_command(<span class="hljs-keyword">char</span> *);   <span class="hljs-comment">//查找命令中的可执行程序</span>
<span class="hljs-keyword">char</span> *msg;  <span class="hljs-comment">//用于myshell提示信息的输出</span>


<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> argcount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">char</span> arglist[<span class="hljs-number">100</span>][<span class="hljs-number">256</span>];
    <span class="hljs-keyword">char</span> **arg = NULL;
    <span class="hljs-keyword">char</span> *buf = NULL;

    buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">256</span>);
    <span class="hljs-keyword">if</span>(buf == NULL)
    {
        perror(<span class="hljs-string">"malloc failed"</span>);
        <span class="hljs-built_in">exit</span>(-<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);    <span class="hljs-comment">//将buf所指的空间清零</span>
        print_prompt();
        get_input(buf);
        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"exit\n"</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"logout\n"</span>) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            arglist[i][<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;
        }
        argcount = <span class="hljs-number">0</span>;
        explain_input(buf, &amp;argcount, arglist);
        do_cmd(argcount, arglist);
    }

    <span class="hljs-keyword">if</span>(buf != NULL)
    {
        <span class="hljs-built_in">free</span>(buf);
        buf = NULL;
    }
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">void</span> print_prompt()
{
    msg = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);
    getcwd(msg, <span class="hljs-number">100</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"myshell@zxq:%s$ "</span>, msg);
    <span class="hljs-built_in">free</span>(msg);
}

<span class="hljs-comment">//获取用户输入</span>
<span class="hljs-keyword">void</span> get_input(<span class="hljs-keyword">char</span> *buf)
{
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> ch;

    ch = getchar();
    <span class="hljs-keyword">while</span>(len &lt; <span class="hljs-number">256</span> &amp;&amp; ch != <span class="hljs-string">'\n'</span>)
    {
        buf[len++] = ch;
        ch = getchar();
    }

    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">256</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"command is too long\n"</span>);
        <span class="hljs-built_in">exit</span>(-<span class="hljs-number">1</span>);
    }
    buf[len] = <span class="hljs-string">'\n'</span>;
    len++;
    buf[len] = <span class="hljs-string">'\0'</span>;
}

<span class="hljs-comment">//解析buf中的命令，将结果存入arglist中，命令以回车符号\n结束</span>
<span class="hljs-keyword">void</span> explain_input(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">int</span> *argcount, <span class="hljs-keyword">char</span> (*arglist)[<span class="hljs-number">256</span>])
{
    <span class="hljs-keyword">char</span> *p = buf;
    <span class="hljs-keyword">char</span> *q = buf;
    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\n'</span>)
        {
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>] == <span class="hljs-string">' '</span>)
        {
            p++;
        }
        <span class="hljs-keyword">else</span>
        {
            q = p;
            number = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>((q[<span class="hljs-number">0</span>] != <span class="hljs-string">' '</span>) &amp;&amp; (q[<span class="hljs-number">0</span>] != <span class="hljs-string">'\n'</span>))
            {
                <span class="hljs-keyword">if</span>(q[<span class="hljs-number">0</span>] == <span class="hljs-number">92</span>)
                {
                    q[<span class="hljs-number">0</span>] = <span class="hljs-string">' '</span>;
                    q[<span class="hljs-number">1</span>] = q[<span class="hljs-number">2</span>];
                    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; ; i++)
                    {
                        q[i] = q[i+<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">if</span>((q[i] == <span class="hljs-string">' '</span>) || (q[i] == <span class="hljs-string">'\n'</span>))
                        <span class="hljs-keyword">break</span>;
                    }
                }
                number++;
                q++;
            }
            <span class="hljs-built_in">strncpy</span>(arglist[*argcount], p, number + <span class="hljs-number">1</span>);
            arglist[*argcount][number] = <span class="hljs-string">'\0'</span>;
            *argcount = *argcount + <span class="hljs-number">1</span>;
            p = q;
        }
    }
}


<span class="hljs-keyword">void</span> do_cmd(<span class="hljs-keyword">int</span> argcount, <span class="hljs-keyword">char</span> (*arglist)[<span class="hljs-number">256</span>])
{
    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> how = <span class="hljs-number">0</span>;    <span class="hljs-comment">//用于只是命令中是否含有&gt; 、 &lt; 、 |</span>
    <span class="hljs-keyword">int</span> background = <span class="hljs-number">0</span>;     <span class="hljs-comment">//标识命令中是否有后台运行的标示符</span>
    <span class="hljs-keyword">int</span> status;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> fd;
    <span class="hljs-keyword">char</span> *arg[argcount + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">char</span> *argnext[argcount + <span class="hljs-number">1</span>];
    pid_t pid;
    <span class="hljs-keyword">char</span> *file;
    <span class="hljs-comment">//将命令取出</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; argcount; i++)
    {
        arg[i] = (<span class="hljs-keyword">char</span> *)arglist[i];
    }
    arg[argcount] = NULL;

    <span class="hljs-comment">//查看命令行是否有后台运行符</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; argcount; i++)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(arg[i], <span class="hljs-string">"&amp;"</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span>(i == argcount - <span class="hljs-number">1</span>)
            {
                background = <span class="hljs-number">1</span>;
                arg[argcount - <span class="hljs-number">1</span>] = NULL;
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"wrong command\n"</span>);
                <span class="hljs-keyword">return</span> ;
            }
        }
    }

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; arg[i] != NULL; i++)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"&gt;"</span>) == <span class="hljs-number">0</span>)
        {
            flag++;
            how = out_readirect;
            <span class="hljs-keyword">if</span>(arg[i + <span class="hljs-number">1</span>] == NULL)
            {
                flag++;
            }
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"&lt;"</span>) == <span class="hljs-number">0</span>)
        {
            flag++;
            how = in_readdirect;
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)
            {
                flag++;
            }
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"|"</span>) == <span class="hljs-number">0</span>)
        {
            flag++;
            how = have_pipe;
            <span class="hljs-keyword">if</span>(arg[i+<span class="hljs-number">1</span>] == NULL)
            {
                flag++;
            }
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)
            {
                flag++;
            }
        }
    }
    <span class="hljs-comment">//flag大于1,说明命令中含有多个&gt; &lt; |符号，本程序是不支持这样的命令的，或命令格式不对</span>
    <span class="hljs-keyword">if</span>(flag &gt; <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"wrong command\n"</span>);
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-keyword">if</span>(how == out_readirect)
    {
        <span class="hljs-comment">//命令只含有一个输出重定向符号</span>
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; arg[i] != NULL; i++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"&gt;"</span>) == <span class="hljs-number">0</span>)
            {
                file = arg[i+<span class="hljs-number">1</span>];
                arg[i] = NULL;
            }
        }
    }

    <span class="hljs-keyword">if</span>(how == in_readdirect)
    {
        <span class="hljs-comment">//命令只含有一个输入重定向</span>
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; arg[i] != NULL; i++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"&lt;"</span>) == <span class="hljs-number">0</span>)
            {
                file = arg[i + <span class="hljs-number">1</span>];
                arg[i] == NULL;
            }
        }
    }

    <span class="hljs-keyword">if</span>(how == have_pipe)
    {
        <span class="hljs-comment">//命令只有一个管道符号，把管道符后面的部分存入argnext中，管道后面的部分是一个可执行的shell命令</span>
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; arg[i] != NULL; i++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[i], <span class="hljs-string">"|"</span>) == <span class="hljs-number">0</span>)
            {
                arg[i] = NULL;
                <span class="hljs-keyword">int</span> j;
                <span class="hljs-keyword">for</span>(j = i + <span class="hljs-number">1</span>; arg[j] != NULL; j++)
                {
                    argnext[j-i-<span class="hljs-number">1</span>] = arg[j];
                }
                argnext[j-i-<span class="hljs-number">1</span>] = arg[j];
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    <span class="hljs-keyword">if</span>((arg[<span class="hljs-number">0</span>] != NULL) &amp;&amp; (<span class="hljs-built_in">strcmp</span>(arg[<span class="hljs-number">0</span>], <span class="hljs-string">"cd"</span>) == <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">if</span>(arg[<span class="hljs-number">1</span>] == NULL)
        {
            <span class="hljs-keyword">return</span> ;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(arg[<span class="hljs-number">1</span>], <span class="hljs-string">"~"</span>) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">strcpy</span>(arg[<span class="hljs-number">1</span>], <span class="hljs-string">"/home/zhuxinquan/"</span>);
        }
        <span class="hljs-keyword">if</span>(chdir(arg[<span class="hljs-number">1</span>]) ==  -<span class="hljs-number">1</span>)
        {
            perror(<span class="hljs-string">"cd"</span>);
        }
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fork error\n"</span>);
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-keyword">switch</span>(how)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        <span class="hljs-comment">//pid为0说明是子进程，在子进程中执行输入的命令</span>
        <span class="hljs-comment">//输入的命令中不含&gt; &lt; |</span>
        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span>(!(find_command(arg[<span class="hljs-number">0</span>])))
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s : command not found\n"</span>, arg[<span class="hljs-number">0</span>]);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            execvp(arg[<span class="hljs-number">0</span>], arg);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        <span class="hljs-comment">//输入的命令中含有输出重定向符</span>
        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span>( !(find_command(arg[<span class="hljs-number">0</span>])) )
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s : command not found\n"</span>, arg[<span class="hljs-number">0</span>]);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            fd = open(file, O_RDWR|O_CREAT|O_TRUNC, <span class="hljs-number">0644</span>);
            dup2(fd, <span class="hljs-number">1</span>);
            execvp(arg[<span class="hljs-number">0</span>], arg);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        <span class="hljs-comment">//输入的命令中含有输入重定向&lt;</span>
        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span>( !(find_command (arg[<span class="hljs-number">0</span>])) )
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s : command not found\n"</span>, arg[<span class="hljs-number">0</span>]);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            fd = open(file, O_RDONLY);
            dup2(fd, <span class="hljs-number">0</span>);
            execvp(arg[<span class="hljs-number">0</span>], arg);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
        <span class="hljs-comment">//输入的命令中含有管道符|</span>
        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">int</span> pid2;
            <span class="hljs-keyword">int</span> status2;
            <span class="hljs-keyword">int</span> fd2;

            <span class="hljs-keyword">if</span>( (pid2 = fork()) &lt; <span class="hljs-number">0</span> )
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fork2 error\n"</span>);
                <span class="hljs-keyword">return</span> ;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid2 == <span class="hljs-number">0</span>)
            {
                <span class="hljs-keyword">if</span>( !(find_command(arg[<span class="hljs-number">0</span>])) )
                {
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s : command not found\n"</span>, arg[<span class="hljs-number">0</span>]);
                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
                }
                fd2 = open(<span class="hljs-string">"/tmp/youdonotknowfile"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="hljs-number">0644</span>);
                dup2(fd2, <span class="hljs-number">1</span>);
                execvp(arg[<span class="hljs-number">0</span>], arg);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            <span class="hljs-keyword">if</span>(waitpid(pid2, &amp;status2, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>)
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"wait for child process error\n"</span>);
            }
            <span class="hljs-keyword">if</span>( !(find_command(argnext[<span class="hljs-number">0</span>])) )
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s : command not found\n"</span>, argnext[<span class="hljs-number">0</span>]);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            fd2 = open(<span class="hljs-string">"/tmp/youdonotknowfile"</span>, O_RDONLY);
            dup2(fd2, <span class="hljs-number">0</span>);
            execvp (argnext[<span class="hljs-number">0</span>], argnext);

            <span class="hljs-keyword">if</span>( remove(<span class="hljs-string">"/tmp/youdonotknowfile"</span>) )
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"remove error\n"</span>);
            }
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-comment">//若命令中有&amp;，表示后台执行，父进程直接返回，不等待子进程结束</span>
    <span class="hljs-keyword">if</span>(background == <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"process id %d \n"</span>, pid);
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-comment">//父进程等待子进程结束</span>
    <span class="hljs-keyword">if</span>(waitpid(pid, &amp;status, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"wait for child process error\n"</span>);
    }
}

<span class="hljs-comment">//查找命令中的可执行程序</span>
<span class="hljs-keyword">int</span> find_command(<span class="hljs-keyword">char</span> *command)
{
    DIR *dp;
    <span class="hljs-keyword">struct</span> dirent *dirp;
    <span class="hljs-keyword">char</span> *path[] = {<span class="hljs-string">"./"</span>, <span class="hljs-string">"/bin"</span>, <span class="hljs-string">"/usr/bin"</span>, NULL};

    <span class="hljs-comment">//使当前目录下的程序可以运行，如命令“./fork”可以被正确解释和执行</span>
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">strncmp</span>(command, <span class="hljs-string">"./"</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> )
    {
        command = command + <span class="hljs-number">2</span>;
    }

    <span class="hljs-comment">//分别在当前目录，/bin和/usr/bin目录查找要执行的程序</span>
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(path[i] != NULL)
    {
        <span class="hljs-keyword">if</span>( (dp= opendir(path[i])) ==NULL )
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"can not open /bin \n"</span>);
        }
        <span class="hljs-keyword">while</span>( (dirp = readdir(dp)) != NULL )
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dirp-&gt;d_name, command) == <span class="hljs-number">0</span>)
            {
                closedir(dp);
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            }
        }
        closedir(dp);
        i++;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
            <div>
                作者：zhuxinquan61 发表于2015/8/1 15:11:21 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47183619">原文链接</a>
            </div>
            <div>
            阅读：124 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47183619#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]进程退出以及内存释放]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47143313</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47143313</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/7/31 8:28:09</pubDate>
            <description><![CDATA[
            <blockquote>
  <p>进程退出表示进程即将结束运行。</p>
</blockquote>

<p>1.正常退出</p>

<ul>
<li>在main函数中执行return。</li>
<li>调用exit函数。</li>
<li>调用_exit函数。</li>
</ul>

<p>2.异常退出</p>

<ul>
<li>调用abort函数</li>
<li>进程收到某个信号，该信号使程序终止。</li>
</ul>

<blockquote>
  <p>进程退出后都会将所有已打开的文件描述符关闭，释放它所占用的内存和其他资源</p>
</blockquote>

<p>各种退出方式之间的比较：</p>

<ul>
<li><strong>exit和return</strong>：exit是一个函数，有参数;return是函数执行完后的返回。exit把控制权交给系统，return将控制权交给的调用函数。</li>
<li><strong>exit和abort</strong>：exit是正常终止进程，abort是异常终止。</li>
<li>exit(int exit_code)：exit中的参数为0代表进程正常终止，若为其他表示程序执行过程有错误发生。</li>
<li><strong>exit()和_exit</strong>：exit在stdlib.h中声明，而_exit声明在unistd.h中。两函数均表示正常终止进程。但_exit()会执行后立即返回给内核，而exit()要先<strong>执行一些清除操作</strong>后才将控制权交给 内核。</li>
</ul>

<blockquote>
  <p>父子进程终止的先后顺序回产生不同的结果，子进程退出前父进程先退出，则会产生孤儿进程，由init进程接管。当子进程先于父进程终止，而父进程又没有调用wait函数等待子进程结束，子进程就回进入僵死状态，子进程进入僵死状态之后内核只保存该进程的一些必要信息以备父进程所需。若父进程调用了wait或waitpid函数，则父进程会等待子进程结束。</p>
</blockquote>

<p>下面这个例子解释了关于退出时的内存释放与否与不同的退出方式之间的联系：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>

<span class="hljs-keyword">int</span> globvar = <span class="hljs-number">5</span>;

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    pid_t pid;
    <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>, i;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fork is diffirent with vfork\n"</span>);

    pid = vfork();
    <span class="hljs-keyword">switch</span>(pid)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        i = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child process is run\n"</span>);
            globvar++;
            var++;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child var = %d\n"</span>, var);
            sleep(<span class="hljs-number">1</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child globvar = %d, var = %d\n"</span>, globvar, var);
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:
        perror(<span class="hljs-string">"parent process failed\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);

        <span class="hljs-keyword">default</span>:
        i = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent process is running\n"</span>);
            globvar++;
            var++;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" parent var = %d\n"</span>, var);
            sleep(<span class="hljs-number">1</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent's globvar = %d, var = %d\n"</span>, globvar, var);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
}</code></pre>

<p>这段代码本来是要测试vfork创建的子进程与父进程公用同一块内存空间，也就是子进程对变量的改变对父进程是可见的。但最终的结果却出乎意料： <br>
<img src="http://img.blog.csdn.net/20150731080430542" alt="这里写图片描述" title=""> <br>
当子进程退出之后，父进程本来应当接着子进程的var进行递加的，但是最终的结果却是子进程退出，父进程的var成为了随机值，后来我在程序的最后添加了exit(0)之后程序的执行结果就变成了这样： <br>
<img src="http://img.blog.csdn.net/20150731081150858" alt="这里写图片描述" title=""> <br>
变量的结果正常了，这是因为在之前case 0时子进程的退出在break之后并未做任何退出函数的调用于是默认是以return结束这个函数的，那么return的退出是函数的退出，函数的退出是会清除在函数内部的局部变量的。所以var值被释放，变成了随机值。当在最后添加exit(0)之后，exit并不会释放栈内存，所以结果正常了。</p>
            <div>
                作者：zhuxinquan61 发表于2015/7/31 8:28:09 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47143313">原文链接</a>
            </div>
            <div>
            阅读：117 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47143313#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]LinuxC系统编程——进程控制(1)]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47128297</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47128297</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/7/30 7:41:40</pubDate>
            <description><![CDATA[
            <h4 id="1linux进程">1.linux进程</h4>

<blockquote>
  <p>进程：是操作系统资源管理的最小单位</p>
</blockquote>

<p>进程是动态的，是程序的一次执行过程，而程序是静态的，进程是运行中的程序，程序只是保存在硬盘上的一些可执行的代码而已，只有当程序转换为进程后，操作系统才为其分配内存单元。</p>



<h4 id="2进程标识">2.进程标识</h4>

<p>在操作系统中每个进程都是通过唯一的进程ID标识的。进程ID是一个非负数，每个进程除了进程ID外还有一些其他标识，它们可以通过相应的函数获得。</p>



<h4 id="3用户id和组id">3.用户ID和组ID：</h4>

<blockquote>
  <p>实际用户ID(<strong>uid</strong>)：标识运行该进程的用户 <br>
  有效用户ID(<strong>euid</strong>)：标识以什么身份来运行进程，eg：某普通用户A以root身份运行A程序，则这个程序的uid就是A用户的ID，而有效用户ID是root用户的ID。 <br>
  实际组ID(<strong>gid</strong>)：它是实际用户所属组的组ID。 <br>
  有效组ID(<strong>egid</strong>)：有效用户所属组的组ID。</p>
</blockquote>



<h4 id="4linux进程的结构">4.linux进程的结构</h4>

<p>linux中进程由代码段、数据段、堆栈段3部分组成。代码段存放程序的可执行代码。数据段存放程序的全局变量、常量、静态变量。堆栈段中的堆用于存放动态分配(<strong>malloc</strong>)的内存变量，栈用于函数调用，存放着函数的参数，函数内部定义的局部变量。</p>



<h4 id="5进程状态">5.进程状态</h4>

<ul>
<li>运行状态（<strong>R</strong>）：程序正在运行</li>
<li>可中断等待状态（<strong>S</strong>）：进程正在等待某个事件完成(如数据到达)。等待过程可被信号或定时器唤醒。</li>
<li>不可中断等待状态（<strong>D</strong>）：进程等待某个事件完成，在等待过程中不可以被信号或定时器唤醒，必须等待直到等待的事件发生。</li>
<li>僵死状态（<strong>Z</strong>）：进程已终止，但进程描述符依然存在，直到父进程调用wait()函数后释放。</li>
<li>停止状态（<strong>T</strong>）：进程因为收到SIGSTOP、SIGSTP、SIGTOU、SIGTIN信号后停止运行或者该进程正在被跟踪（调试状态）。</li>
</ul>



<h4 id="6进程控制">6.进程控制</h4>

<p>linux进程控制包括创建进程、执行新程序、退出进程以及改变进程的优先级，通常通过一系列的系统调用来控制进程。主要系统调用如下： <br>
 - fork：用于创建一个新进程 <br>
 - exit：用于终止进程 <br>
 - exec：用于执行一个应用程序 <br>
 - wait：将父进程挂起，等待子进程终止 <br>
 - getpid：获取当前进程的进程ID <br>
 - nice：改变进程的优先级</p>



<h4 id="7进程的内存映像">7.进程的内存映像</h4>

<blockquote>
  <p>linux下程序转化成进程</p>
</blockquote>

<p>linux下C程序的<strong>生成</strong>分为4个阶段：预编译、编译、汇编、链接。程序转化为进程通常要经过以下步骤：</p>

<ol>
<li>内核将程序读入内存，为程序分配内存空间</li>
<li>内核为该进程分配进程标示符（PID）和其他所需资源</li>
<li>内核为进程保存PID及相应的状态信息，把进程放到运行队列中等待执行。程序转化为进程之后就可以被操作系统的调度程序执行了。</li>
</ol>

<blockquote>
  <p>进程的内存映像：进程的内存映像是指内核在内存中如何存放可执行程序文件</p>
</blockquote>

<p>linux程序影像从内存的低地址到高地址依次如下：</p>

<ol>
<li>代码段：即二进制机器代码，代码段只读，可被多个进程共享。</li>
<li>数据段：存储已被初始化的变量，包括全局变量和已被初始化的静态变量。</li>
<li>未初始化数据段：存储未被初始化的静态变量。</li>
<li>堆：用于存放数据运行中动态分配的变量</li>
<li>栈：用于函数待用，保存函数的返回地址、函数的参数、函数内部定义的局部变量</li>
</ol>



<h4 id="8进程的创建">8.进程的创建</h4>

<p>创建进程有两种方式，一是由操作系统创建，二是由父进程创建。操作系统创建的进程，它们之间是平等的，一般不存在资源继承关系。而对于父进程创建的进程（子进程），它和父进程存在隶属关系。</p>

<blockquote>
  <p>fork函数</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs cpp">   <span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
   pid_t fork(<span class="hljs-keyword">void</span>);
</code></pre>

<p>fork函数有两个返回值，fork函数调用成功之后当前进程就已经分为两个进程，即每个进程有一个返回值，父进程的返回值是子进程的ID，子进程的返回值是0，若fork函数执行失败，则只有一个返回值-1，通过不同的返回值可以区分父子进程。</p>

<blockquote>
  <p>在fork之后父子进程谁先执行是不确定的，取决于内核使用的调度算法</p>
</blockquote>

<p>fork在创建进程失败的原因通常是父进程拥有的子进程的个数超过了规定的限制（errno值为EAGAIN），或是可供使用的内存不足（errno值为ENOMEN）。 <br>
子进程会继承父进程的很多属性主要有用户ID、组ID、当前工作目录、根目录、打开的文件、创建文件时使用的屏蔽字 <br>
、信号屏蔽字、上下文环境、共享的存储段、资源限制等。 <br>
同时子进程与父进程还有一些不相同的属性：</p>

<ul>
<li>子进程有它自己唯一的进程ID</li>
<li>fork的返回值不同，父进程返回子进程的ID，子进程返回0</li>
<li>不同的父进程ID，子进程的父进程ID为创建它的父进程</li>
<li>子进程共享父进程打开的文件描述符，但父进程对文件描述符的改变不会影响子进程中的文件描述符</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程不继承父进程设置的警告</li>
<li>子进程的未决信号集被清空 <br>


<blockquote>
  信号的”未决“是一种状态，指的是从信号的产生到信号被处理前的这一段时间</blockquote></li>
  </ul>



<h4 id="9孤儿进程">9.孤儿进程</h4>



<blockquote>
  <p>如果一个子进程的父进程先于子进程结束，子进程就成为一个孤儿进程，它由init（<strong>是内核启动的第一个用户级进程</strong>）进程收养，成为init进程的子进程 <br>
  孤儿进程的测试代码如下：</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    pid_t pid;

    pid = fork();
    <span class="hljs-keyword">switch</span>(pid)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        {
            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child process is run, pid is %d, parent id is %d.\n"</span>, getpid(), getppid());
                sleep(<span class="hljs-number">3</span>);
            }
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:
        {
            perror(<span class="hljs-string">"process creat failed:"</span>);
            <span class="hljs-built_in">exit</span>(-<span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">default</span>:
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent process is run!"</span>);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20150730074205603" alt="这里写图片描述" title=""> <br>
由执行结果可以看出刚开始子进程的父进程pid为6994，当父进程执行结束退出后，子进程成为孤儿进程。</p>



<h4 id="10vfork函数">10.vfork函数</h4>

vfork也可以用来创建一个新进程，同样是调用一次，返回两次，与fork函数不同的是创建的子进程和父进程共享父进程的地址空间，子进程对该地址空间的修改对父进程同样有效。使用vfork创建的进程保证子进程先运行，当它调用exec或exit之后，父进程才有可能被调度运行。如果在调用exec或exit之前子进程要依赖父进程的某个行为，就会导致死锁。
当fork一个进程之后立即调用了exec执行另外一个应用程序，那么fork过程子进程对父进程的地址空间的复制将是一个多余的过程。vfork不会拷贝父进程的地址空间。










<h4 id="11创建守护进程">11.创建守护进程</h4>



<blockquote>
  <p>守护进程(daemon)：指在后台运行的、没有控制终端与之相连的进程。</p>
</blockquote>

编写创建守护进程有如下要点：

<ul>
<li><strong>让进程在后台执行。</strong>调用fork产生一个子进程，然后使得父进程退出。</li>
<li><p><strong>调用setsid创建一个新对话</strong>，控制终端，登陆会话和进程组通常是从父进程继承下来的，</p>

<blockquote>
  <p>当进程是会话组长时，调用setsid会失败（第一点已保证不是会话组长），setsid调用成功后，进程成为新的会话组长和进程组长，并与原来的登陆会话和进程组脱离，由于会话过后才能够对控制终端的独占性，进程同时与控制终端脱离</p>
</blockquote></li>
<li><p><strong>禁止进程重新打开控制终端。</strong>此时进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免可以通过使进程不再是会话组长来实现：再一次通过fork创建新的子进程，使调用fork的进程退出。</p></li>
<li><strong>关闭不再需要的文件描述符。</strong>创建的子进程从父进程继承打开的文件描述符，如不关闭，回浪费系统资源，造成进程所在文件系统无法卸下以及引起无法预料的错误。先得到最高的文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</li>
<li><strong>将当前目录更改为根目录</strong>，当守护进程当前工作目录在一个装配文件系统中时，系统不能被拆卸。</li>
<li><strong>将文字创建时使用的屏蔽字设置为0</strong>，进程会继承父进程使用的文件创建屏蔽字，这样在子进程中文件创建屏蔽字可能回拒绝某些许可权，为了防止，一般使用umask(0)将屏蔽字清零。</li>
<li><strong>处理SIGCHLD信号。</strong>非必须，如果父进程不等待子进程结束，子进程将成为僵尸进程，占用系统资源，但当父进程等待子进程结束会增加父进程的负担，影响服务器进程的并发性。linux下可以<strong>将SIGCHLD信号的操作设为SIG_IGN</strong>，这样就不会产生僵尸进程。</li>
</ul>
            <div>
                作者：zhuxinquan61 发表于2015/7/30 7:41:40 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47128297">原文链接</a>
            </div>
            <div>
            阅读：89 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47128297#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]LinuxC编程——实现自己的ls -R -a -l]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/47035395</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/47035395</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/7/24 16:58:27</pubDate>
            <description><![CDATA[
            <p>要实现自己的ls命令首先要有自己的框架结构，完整的框架结构不至于让你在编写代码的过程中突然没了思路。我的思路如下：</p>

<ol>
<li><p>首先就是解析参数，对于参数的解析，可以采用或运算来定义，比如将没有参数定义为0，将-a定义为1，将-l定义为2，将-R定义为4等，这样的优点实质就是采取了二进制位的或运算的优势，对与每一位刚好代表不同的参数，这样就可以将所有的参数保存在一个int型的数中，当后面要查看是否有某个参数时，只需要判断一下这一位是否是1，即就是在使用一次与运算来得到结果。</p></li>
<li><p>对于目录的解析与参数是类似的，但是首先就是要将目录的参数与ls的参数（-a, -l, -R）能够区分开来，那么一个明显的标志就是ls命令本身的参数在之前是带有字符 ‘-’ 的，因而我们可以很方便的将两种参数区分开来，从而获得路径的参数。</p></li>
<li><p>对于显示，应当是由目录的解析开始，对于目录，我们可以使用opendir()函数来进行读取从而得到这一个文件夹中文件的名称，并将其使用 strcat()函数连接在path之后，组合成为带有文件名的pathname，其实到这里就等于将一个文件的完整路径包括文件名在内的完整信息的到了，然后反复利用opendir函数得到本目录下所有的完整文件路径将其存入一个二维数组当中。</p></li>
<li><p>接下来就是显示的工作，对于 ‘-a’ 参数和没有参数区别在于是否显示隐藏文件。对于这样的区别只需要用一个if条件进行判断文件名的开头是否是 ’ . ’ 即可。对于-l，则需要将文件的所有信息进行输出，即就是在-l输出函数内部要将文件的读取权限，链接数，所有者，所属组，文件名，时间信息统统显示出来，在往 ‘-l’ 信息输出函数的参数传递中就要将包含文件明的完整路径信息以及文件属性信息传入到-l输出函数中，然后在本函数中将属性的所有信息进行输出即可。</p></li>
<li><p>最后就是-R参数的输出，对于-R参数的最后的输出实质依旧是利用以上的函数，只是增加了递归调用，以及路径名的改变。在这一递归函数中，起初也是传入一个路径名，然后利用与之前相同的-a将此目录进行显示输出，不过，才此需要注意的是，到这里只是将当前路径名下的文件以及目录进行了输出，然后就是将当前path加上本文件夹下的文件夹的名称组成 pathname当做path重新调用-R输出函数，使之递归输出。需要注意的是在输出完成之后返回上一层目录，准备将下一个文件夹接到path后面之前要先将之前path后面接的name删除掉，这样每次递归调用返回到上一层之后可以保证父目录没有被改变。</p></li>
</ol>



<h4 id="注意"><strong>注意：</strong></h4>

<ol>
<li>在执行输出时有时侯打开文件夹需要权限，所以可以再sudo下执行</li>
<li>在执行-R递归显示时由于堆栈区大小限制，可能导致堆栈区溢出，测试时可对低级目录进行测试</li>
</ol>

<p>具体代码如下：</p>

<pre class="prettyprint"><code class=" hljs cpp">
<span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;time.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;linux/limits.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;dirent.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;grp.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;pwd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;errno.h&gt;</span>


<span class="hljs-preprocessor">#define PARAM_NONE 0    <span class="hljs-comment">//无参数</span></span>
<span class="hljs-preprocessor">#define PARAM_A 1   <span class="hljs-comment">//-a :显示所有文件</span></span>
<span class="hljs-preprocessor">#define PARAM_L 2 <span class="hljs-comment">//-l ：一行显示一个文件的详细信息</span></span>
<span class="hljs-preprocessor">#define PARAM_r 4 <span class="hljs-comment">//-r : 逆序排列输出</span></span>
<span class="hljs-preprocessor">#define MAXROWLEN 80 <span class="hljs-comment">//一行最多显示的字符数</span></span>
<span class="hljs-keyword">void</span> ls_R(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> **);
<span class="hljs-keyword">int</span> recursion(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> *);
<span class="hljs-keyword">int</span> g_leave_len = MAXROWLEN;    <span class="hljs-comment">//一行剩余长度，用于输出对齐</span>
<span class="hljs-keyword">int</span> g_maxlen;   <span class="hljs-comment">//存放某目录下最长的文件名的长度</span>

<span class="hljs-comment">//错误打印函数</span>
<span class="hljs-keyword">void</span> my_err(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *err_string, <span class="hljs-keyword">int</span> line)
{
    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"line:%d "</span>, line);
    perror(err_string);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">//获取文件属性并打印</span>
<span class="hljs-keyword">void</span> display_attribute(<span class="hljs-keyword">struct</span> stat buf, <span class="hljs-keyword">char</span> * name)
{
    <span class="hljs-keyword">char</span> buf_time[<span class="hljs-number">32</span>];
    <span class="hljs-keyword">struct</span> passwd *psd;     <span class="hljs-comment">//从该结构体获取文件所有者的用户名</span>
    <span class="hljs-keyword">struct</span> group *grp;      <span class="hljs-comment">//从该结构体获取文件所有者所属组的组名</span>

    <span class="hljs-comment">//获取并打印文件类型</span>
    <span class="hljs-keyword">if</span> (S_ISLNK(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"l"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISREG(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISDIR(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"d"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S_ISCHR(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"c"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISBLK(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"b"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISFIFO(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"f"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S_ISSOCK(buf.st_mode))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"s"</span>);
    }

    <span class="hljs-comment">//获取并打印文件所有者的权限</span>
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IRUSR)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"r"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IWUSR)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"w"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IXUSR)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }

    <span class="hljs-comment">//获取并打印与文件所有者同组的用户对该文件的操作权限</span>
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IRGRP)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"r"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IWGRP)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"w"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span>(buf.st_mode &amp; S_IXGRP)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }

    <span class="hljs-comment">//获取并打印其他用户对该文件的操作权限</span>
    <span class="hljs-keyword">if</span> (buf.st_mode &amp; S_IROTH)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"r"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span> (buf.st_mode &amp; S_IWOTH)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"w"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }
    <span class="hljs-keyword">if</span> (buf.st_mode &amp; S_IXOTH)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-"</span>);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"    "</span>);

    <span class="hljs-comment">//根据uid与gid获取文件所有者的用户名与组名</span>
    psd = getpwuid(buf.st_uid);
    grp = getgrgid(buf.st_gid);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%4d "</span>, (<span class="hljs-keyword">int</span>)buf.st_nlink);   <span class="hljs-comment">//打印文件的链接数</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-12s"</span>, psd-&gt;pw_name);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-12s"</span>, grp-&gt;gr_name);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%6d"</span>, (<span class="hljs-keyword">int</span>)buf.st_size);     <span class="hljs-comment">//打印文件大小</span>
    <span class="hljs-built_in">strcpy</span>(buf_time, ctime(&amp;buf.st_mtime));
    buf_time[<span class="hljs-built_in">strlen</span>(buf_time) - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;  <span class="hljs-comment">//取掉换行符</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s"</span>, buf_time);   <span class="hljs-comment">//打印文件的时间信息</span>
}

<span class="hljs-comment">//在没有使用-l选项时，打印一个文件名，打印时保证上下对齐</span>
<span class="hljs-keyword">void</span> display_single(<span class="hljs-keyword">char</span> *name)
{
    <span class="hljs-keyword">int</span> i,len;

    <span class="hljs-comment">//如果本行不足以打印一个文件名则换行</span>
    <span class="hljs-keyword">if</span>(g_leave_len &lt; g_maxlen)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        g_leave_len = MAXROWLEN;
    }

    len = <span class="hljs-built_in">strlen</span>(name);
    len = g_maxlen - len;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-s"</span>, name);

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  "</span>);
    g_leave_len -= (g_maxlen + <span class="hljs-number">2</span>);  <span class="hljs-comment">//2指示两空格</span>
}

<span class="hljs-comment">//根据命令行参数和完整路径名显示目标文件</span>
<span class="hljs-comment">//参数flag：命令行参数</span>
<span class="hljs-comment">//参数pathname：包含了文件名的路径名</span>

<span class="hljs-keyword">void</span> display(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">char</span> *pathname)
{
    <span class="hljs-keyword">int</span> i,j;
    <span class="hljs-keyword">struct</span> stat buf;
    <span class="hljs-keyword">char</span> name[NAME_MAX + <span class="hljs-number">1</span>];

    <span class="hljs-comment">//从路径中解析出文件名</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(pathname); i++)
    {
        <span class="hljs-keyword">if</span>(pathname[i] == <span class="hljs-string">'/'</span>)
        {
            j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">continue</span>;
        }
        name[j++] = pathname[i];
    }
    name[j] = <span class="hljs-string">'\0'</span>;

    <span class="hljs-comment">//用lstat而不是stat以方便解析链接文件</span>
    <span class="hljs-keyword">if</span>(lstat(pathname, &amp;buf) == -<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"权限不足！！\n"</span>);
        <span class="hljs-keyword">return</span> ; <span class="hljs-comment">////////////////////////////////////////</span>
        my_err(<span class="hljs-string">"stat"</span>, __LINE__);
    }

    <span class="hljs-keyword">switch</span>(flag)
    {
        <span class="hljs-keyword">case</span> PARAM_NONE:    <span class="hljs-comment">//没有-l和-a选项</span>
        <span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>] != <span class="hljs-string">'.'</span>)
        {
            display_single(name);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_r:    <span class="hljs-comment">//-r</span>
        <span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>] != <span class="hljs-string">'.'</span>)
        {
            display_single(name);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_A:   <span class="hljs-comment">//-a:显示包括隐藏文件在内的所有文件</span>
        display_single(name);
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_L:   <span class="hljs-comment">//-l:每个文件单独占一行</span>
        <span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>] != <span class="hljs-string">'.'</span>)
        {
            display_attribute(buf, name);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %-s\n"</span>, name);
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_A + PARAM_L:     <span class="hljs-comment">//同时有-a和-l选项的情况</span>
        display_attribute(buf, name);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %-s\n"</span>, name);
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_r + PARAM_A:    <span class="hljs-comment">//-ar</span>
        display_single(name);
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> PARAM_L + PARAM_r:     <span class="hljs-comment">//-rl</span>
        <span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>] != <span class="hljs-string">'.'</span>)
        {
            display_attribute(buf, name);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %-s\n"</span>, name);
        }
        <span class="hljs-keyword">break</span>;

        defualt:
        <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-keyword">void</span> display_dir(<span class="hljs-keyword">int</span> flag_param, <span class="hljs-keyword">char</span> *path)
{
    DIR *dir;
    <span class="hljs-keyword">struct</span> dirent *ptr;
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">char</span> filename[<span class="hljs-number">600</span>][PATH_MAX+<span class="hljs-number">1</span>],temp[PATH_MAX + <span class="hljs-number">1</span>];

    <span class="hljs-comment">//获取该目录下文件总数和最长文件名</span>
    dir = opendir(path);
    <span class="hljs-keyword">if</span> (dir == NULL)
    {
        my_err(<span class="hljs-string">"opendir"</span>, __LINE__);
    }
    <span class="hljs-keyword">while</span>((ptr =readdir(dir)) != NULL)
    {
        <span class="hljs-keyword">if</span>(g_maxlen &lt; <span class="hljs-built_in">strlen</span>(ptr-&gt;d_name))
        {
            g_maxlen = <span class="hljs-built_in">strlen</span>(ptr-&gt;d_name);
        }
        count++;
    }
    closedir(dir);

    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">600</span>)
    {
        <span class="hljs-comment">//printf("%d", count);</span>
        my_err(<span class="hljs-string">"too many file under this dir"</span>, __LINE__);
    }

    <span class="hljs-keyword">int</span> i, j, len = <span class="hljs-built_in">strlen</span>(path);
    dir = opendir(path);    <span class="hljs-comment">//获取该目录下所有的文件名</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; count; i++)
    {
        ptr = readdir(dir);
        <span class="hljs-keyword">if</span>(ptr == NULL)
        {
            my_err(<span class="hljs-string">"readdir"</span>, __LINE__);
        }
        <span class="hljs-built_in">strncpy</span>(filename[i], path, len);
        filename[i][len] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-built_in">strcat</span>(filename[i], ptr-&gt;d_name);
        filename[i][len + <span class="hljs-built_in">strlen</span>(ptr-&gt;d_name)] = <span class="hljs-string">'\0'</span>;
    }
    closedir(dir);

    <span class="hljs-comment">//使用冒泡法对文件名进行排序，排序后文件名按字母顺序存储与filename</span>
    <span class="hljs-keyword">if</span>(flag_param &amp; PARAM_r)
    {
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; count - <span class="hljs-number">1</span>; i++)
        {
            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; count - <span class="hljs-number">1</span> - i; j++)
            {
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(filename[j], filename[j+<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)
                {
                    <span class="hljs-built_in">strcpy</span>(temp, filename[j + <span class="hljs-number">1</span>]);
                    temp[<span class="hljs-built_in">strlen</span>(filename[j+<span class="hljs-number">1</span>])] = <span class="hljs-string">'\0'</span>;
                    <span class="hljs-built_in">strcpy</span>(filename[j+<span class="hljs-number">1</span>], filename[j]);
                    filename[j+<span class="hljs-number">1</span>][<span class="hljs-built_in">strlen</span>(filename[j])] = <span class="hljs-string">'\0'</span>;
                    <span class="hljs-built_in">strcpy</span>(filename[j], temp);
                    filename[j][<span class="hljs-built_in">strlen</span>(temp)] = <span class="hljs-string">'\0'</span>;
                }
            }
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; count - <span class="hljs-number">1</span>; i++)
        {
            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; count - <span class="hljs-number">1</span> - i; j++)
            {
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(filename[j], filename[j+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)
                {
                    <span class="hljs-built_in">strcpy</span>(temp, filename[j + <span class="hljs-number">1</span>]);
                    temp[<span class="hljs-built_in">strlen</span>(filename[j+<span class="hljs-number">1</span>])] = <span class="hljs-string">'\0'</span>;
                    <span class="hljs-built_in">strcpy</span>(filename[j+<span class="hljs-number">1</span>], filename[j]);
                    filename[j+<span class="hljs-number">1</span>][<span class="hljs-built_in">strlen</span>(filename[j])] = <span class="hljs-string">'\0'</span>;
                    <span class="hljs-built_in">strcpy</span>(filename[j], temp);
                    filename[j][<span class="hljs-built_in">strlen</span>(temp)] = <span class="hljs-string">'\0'</span>;
                }
            }
        }
    }

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; count; i++)
    {
        display(flag_param, filename[i]);
    }


    <span class="hljs-comment">//如果命令行没有-l选项，打印一个换行符          </span>
    <span class="hljs-keyword">if</span>((flag_param &amp; PARAM_L) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> i, j, k, num;
    <span class="hljs-comment">//char path[PARAM_NONE + 1];</span>
    <span class="hljs-keyword">char</span> param[<span class="hljs-number">32</span>];     <span class="hljs-comment">//保存命令行参数，目标文件和目录名不在此例</span>
    <span class="hljs-keyword">int</span> flag_param = PARAM_NONE;    <span class="hljs-comment">//参数种类，即是否有-l和-a选项</span>
    <span class="hljs-keyword">struct</span> stat buf;

    <span class="hljs-keyword">char</span> *path = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(PATH_MAX+<span class="hljs-number">1</span>);
    <span class="hljs-comment">//命令行参数的解析，分析-l,-a,-al,-la选项</span>
    j = <span class="hljs-number">0</span>;
    num = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)
    {
        <span class="hljs-keyword">if</span>(argv[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>)
        {
            <span class="hljs-keyword">for</span>(k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-built_in">strlen</span>(argv[i]); k++, j++)
            {
                param[j] = argv[i][k];  <span class="hljs-comment">//获取'-'后面的参数保存到数组param中</span>
            }
            num++;      <span class="hljs-comment">//保存'-'的个数</span>
        }
    }

    <span class="hljs-comment">//只支持a和l和r，如果含有其它选项就报错</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; j; i++)
    {
        <span class="hljs-keyword">if</span>(param[i] == <span class="hljs-string">'a'</span>)
        {
            flag_param |= PARAM_A;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(param[i] == <span class="hljs-string">'l'</span>)
        {
            flag_param |= PARAM_L;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(param[i] == <span class="hljs-string">'r'</span>)
        {
            flag_param |= PARAM_r;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(param[i] == <span class="hljs-string">'R'</span>)
        {
            <span class="hljs-built_in">free</span>(path);
            ls_R(argc, argv);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"my_ls: invalid opention -%c\n"</span>, param[i]);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }
    }
    param[j] = <span class="hljs-string">'\0'</span>;

    <span class="hljs-comment">//如果没有输入文件名或目录，就显示当前目录</span>
    <span class="hljs-keyword">if</span>((num + <span class="hljs-number">1</span>) == argc)
    {
        <span class="hljs-built_in">strcpy</span>(path, <span class="hljs-string">"./"</span>);
        path[<span class="hljs-number">2</span>] = <span class="hljs-string">'\0'</span>;
        display_dir(flag_param, path);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    i = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-comment">//如果不是目标文件名或目录，解析下一个命令行参数</span>
        <span class="hljs-keyword">if</span>(argv[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>)
        {
            i++;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//printf("%d\n", i);</span>
            <span class="hljs-comment">//strcpy(path, argv[i]);</span>
            <span class="hljs-built_in">strncpy</span>(path, argv[i],<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>);
            <span class="hljs-comment">//如果目标文件或目录不存在，报错并退出程序</span>
            <span class="hljs-comment">//printf("%d\n", i);</span>
            <span class="hljs-comment">//puts(path);</span>
            <span class="hljs-keyword">if</span>(stat(path, &amp;buf) == -<span class="hljs-number">1</span>)
            {
                my_err(<span class="hljs-string">"stat"</span>, __LINE__);
            }
            <span class="hljs-keyword">if</span>(S_ISDIR(buf.st_mode))    <span class="hljs-comment">//argv[i]是一个目录</span>
            {
                <span class="hljs-keyword">if</span>(path[<span class="hljs-built_in">strlen</span>(argv[i])-<span class="hljs-number">1</span>] != <span class="hljs-string">'/'</span>)  <span class="hljs-comment">//如果目录的最后一个字符不是'/',就加上'/'</span>
                {
                    path[<span class="hljs-built_in">strlen</span>(argv[i])] = <span class="hljs-string">'/'</span>;
                    path[<span class="hljs-built_in">strlen</span>(argv[i]) + <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    path[<span class="hljs-built_in">strlen</span>(argv[i])] = <span class="hljs-string">'\0'</span>;
                }
                display_dir(flag_param, path);
                i++;
            }
            <span class="hljs-keyword">else</span>    <span class="hljs-comment">//argv[i]是一个文件</span>
            {
                display(flag_param, path);
                i++;
            }
        }
    }<span class="hljs-keyword">while</span>(i &lt; argc);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">void</span> ls_R(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> flag_param = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">struct</span> stat buf;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span> path[<span class="hljs-number">500</span>];
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)
    {
        <span class="hljs-keyword">if</span>(argv[i][<span class="hljs-number">0</span>] != <span class="hljs-string">'-'</span>)
        {
            <span class="hljs-built_in">strcpy</span>(path, argv[i]);
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%s:\n"</span>, path);
    recursion(flag_param, path);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">int</span> recursion(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">char</span> *path)
{
    DIR *dir;
    <span class="hljs-keyword">struct</span> dirent *ptr;
    <span class="hljs-keyword">char</span> pathname[<span class="hljs-number">10000</span>];     <span class="hljs-comment">//带有文件名称的路径</span>
    <span class="hljs-keyword">int</span> flag_param = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">struct</span> stat buf;
    <span class="hljs-keyword">int</span> len, i;
    display_dir(flag_param, path);
    <span class="hljs-comment">//pathname = (char *)malloc(PATH_MAX);</span>
    <span class="hljs-built_in">strcpy</span>(pathname, path);
    dir = opendir(path);
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        ptr = readdir(dir);
        <span class="hljs-keyword">if</span>(ptr == NULL)
        {
            closedir(dir);
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">strcmp</span>(ptr-&gt;d_name,<span class="hljs-string">"."</span>) &amp;&amp; (<span class="hljs-built_in">strcmp</span>(ptr-&gt;d_name, <span class="hljs-string">".."</span>) &amp;&amp; ptr-&gt;d_name[<span class="hljs-number">0</span>] != <span class="hljs-string">'.'</span>)))
        {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-built_in">strcat</span>(pathname, ptr-&gt;d_name);
        lstat(pathname, &amp;buf);
        <span class="hljs-keyword">if</span>(S_ISDIR(buf.st_mode))
        {
            len = <span class="hljs-built_in">strlen</span>(pathname);
            pathname[len] = <span class="hljs-string">'/'</span>;
            pathname[len + <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%s:\n"</span>, pathname);
            g_maxlen = <span class="hljs-number">0</span>;
            g_leave_len = MAXROWLEN;
            recursion(flag, pathname);
        }
        <span class="hljs-keyword">for</span>(i = <span class="hljs-built_in">strlen</span>(path); i &lt; len ; i++)
        {
            pathname[i] = <span class="hljs-string">'\0'</span>;
        }
    }
}</code></pre>
            <div>
                作者：zhuxinquan61 发表于2015/7/24 16:58:27 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47035395">原文链接</a>
            </div>
            <div>
            阅读：107 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/47035395#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]linux系统编程文件——文件操作总结(3)]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/46986057</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/46986057</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/7/21 14:50:11</pubDate>
            <description><![CDATA[
            <h4 id="1文件的移动"><strong>1.文件的移动</strong></h4>

<p>rename系统调用可以用来修改文件名或文件的位置。</p>



<pre class="prettyprint"><code class=" hljs cpp">  <span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
  <span class="hljs-keyword">int</span> rename(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath);
</code></pre>

<p>rename会将参数oldpath所指定的文件名称改为参数newpath所指定的文件名称。若newpath所指定的文件已存在，则<strong>原文件会被删除</strong>。执行成功返回0，失败返回-1。</p>



<h4 id="2文件的删除"><strong>2.文件的删除</strong></h4>

<p>文件的删除可以使用unlink系统调用，目录文件的删除可以使用rmdir系统调用，remove在内部封装了unlink和rmdir，当需要删除的是文件时，调用unlink，反之则调用rmdir。</p>



<pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
 <span class="hljs-keyword">int</span> unlink(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname);
 <span class="hljs-keyword">int</span> rmdir(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname);
</code></pre>

<p>unlink系统调用从文件系统中删除一个文件，如果文件的链接数为0且没有进程打开这个文件，则文件被删除且其占用的磁盘空间被释放。如果文件的连接数虽为0，但是有进程打开这个文件则文件<strong>暂时不删除</strong>，直到所有打开该文件的进程都结束时文件才被删除。 <br>
参数pathname若指向一个符号链接，则该链接被删除，若参数pathname指向一个socket(套接字文件)、FIFO(命名管道)或设备文件时，该名字被删除，但已经打开这些文件的进程仍然可以使用这些特殊文件。函数执行成功返回0。失败返回-1。 <br>
如下的unlink应用：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>

<span class="hljs-comment">//自定义的错误处理函数</span>
<span class="hljs-keyword">void</span> my_err(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * err_string, <span class="hljs-keyword">int</span> line)
{
    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"line:%d"</span>, line);
    perror(err_string);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> fd;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];

    <span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">"temp"</span>, O_RDWR|O_CREAT|O_TRUNC)) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"open"</span>, __LINE__);
    }

    <span class="hljs-keyword">if</span>(unlink(<span class="hljs-string">"temp"</span>) &lt; <span class="hljs-number">0</span> )
    {
        my_err(<span class="hljs-string">"unlink"</span>, __LINE__);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"file unlinked\n"</span>);

    <span class="hljs-keyword">if</span>(write(fd, <span class="hljs-string">"temp"</span>, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"write"</span>, __LINE__);
    }
    <span class="hljs-keyword">if</span>((lseek(fd, <span class="hljs-number">0</span>, SEEK_SET)) == -<span class="hljs-number">1</span>)
    {
        my_err(<span class="hljs-string">"lseek"</span>, __LINE__);
    }
    <span class="hljs-keyword">if</span>(read(fd, buf, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"read"</span>, __LINE__);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>程序在执行过程中，在开始以可读可写的方式创建并打开了temp文件，由于进程并没有结束，所以unlink函数执行时暂时不会删除打开的temp文件，并且之后的temp文件读取是正常的，但是在程序执行结束之后temp却不存在，就是因为unlink在进程释放之后，将temp文件删除了。</p>



<h4 id="3目录的创建"><strong>3.目录的创建</strong></h4>

<p>目录的创建可以由mkdir系统调用来实现。</p>



<pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-preprocessor">#include &lt;sys/stat.h&gt;</span>
 <span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
 <span class="hljs-keyword">int</span> mkdir(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, mode_t mode);
</code></pre>

<p>mkdir创建一个新的空目录。空目录中会自动创建.和..目录项，所创建的目录的存取权限由mode(mode &amp; ~umask)指定。新目录的uid与创建目录的进程的uid一致。如果父目录设置了st_gid位，则创建的目录也设置 st_uid(目录被设置该位后，任何用户在此目录下创建的文件的组id与该目录的组id相同)，函数执行成功返回0，失败返回-1。</p>



<h4 id="4获取当前目录"><strong>4.获取当前目录</strong></h4>

<p><strong>相对路径</strong>：不以斜线(根)开始的路径名 <br>
getcwd系统调用可以获取进程当前工作目录</p>



<pre class="prettyprint"><code class=" hljs cpp">  <span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
  <span class="hljs-keyword">char</span> *getcwd(<span class="hljs-keyword">char</span> *buf, size_t size);
  <span class="hljs-keyword">char</span> *getwd(<span class="hljs-keyword">char</span> *buf);
  <span class="hljs-keyword">char</span> *get_current_dir_name(<span class="hljs-keyword">void</span>);</code></pre>

<p>getcwd会将当前的工作目录绝对路径复制到参数buf所指的内存空间，参数size为buf的空间大小。在调用此函数时，buf所指的空间要<strong>足够大</strong>，若工作目录绝对路径的字符串长度超过参数size大小，则返回NULL，若参数buf为NULL，getcwd()会根据参数size的大小自动分配内存，如果参数size也为0，则getcwd()会根据工作目录绝对路径的字符串长度来决定配置的内存大小，同时，进程在使用完此字符串之后利用free()释放此空间。执行成功则将结果复制到参数buf所指的内存空间，或是返回自动配置的字符串指针，失败返回NULL。</p>



<h4 id="5设置工作目录"><strong>5.设置工作目录</strong></h4>

<p>使用chdir更改当前工作目录</p>



<pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
 <span class="hljs-keyword">int</span> chdir(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path);
 <span class="hljs-keyword">int</span> fchdir(<span class="hljs-keyword">int</span> fd);</code></pre>

<p>chdir用来将当前工作目录改为由参数pathname指定的目录，fchdir用来将当前工作目录改为由参数fd(文件描述符)指定的目录。const char *path中的const含义是：在chdir函数实现代码中不允许path所指向的字符串的内容进行改变。函数执行成功返回0，有错误时返回-1。 <br>
利用chdir编写的cd命令如下:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;linux/limits.h&gt;</span>

<span class="hljs-comment">//自定义错误处理函数</span>
<span class="hljs-keyword">void</span> my_err(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * err_string, <span class="hljs-keyword">int</span> line)
{
    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"line:%d"</span>, line);
    perror(err_string);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">char</span> buf[PATH_MAX + <span class="hljs-number">1</span>];

    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"my_cd &lt;target path&gt;\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(chdir(argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"getcwd"</span>, __LINE__);
    }
    <span class="hljs-keyword">if</span>(getcwd(buf, <span class="hljs-number">512</span>) &lt; <span class="hljs-number">0</span>)
    {
        my_err(<span class="hljs-string">"getcwd"</span>, __LINE__);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20150721163355004" alt="执行结果如下" title=""> <br>
程序先使用chdir系统调用将当前工作目录改变为命令行参数指定的目录，然后利用getcwd获取新的工作目录并打印出来，可以看出，虽然程序改变了该进程的工作目录，但并不能像cd命令一样切换目录，因为chdir函数调用只改变调用该函数的进程，对其他进程，如父进程的当前工作目录，则修改不了。</p>



<h4 id="6获取目录信息"><strong>6.获取目录信息</strong></h4>

<ol>
<li>opendir：用来打开参数name指定的目录，并返回DIR*形态的目录流，类似与文件中的文件描述符。成功返回目录流，失败返回NULL。</li>
<li>readdir：</li>
</ol>



<pre class="prettyprint"><code class=" hljs perl"> <span class="hljs-comment">#include &lt;dirent.h&gt;</span>
 struct dirent <span class="hljs-variable">*readdir</span>(DIR <span class="hljs-variable">*dirp</span>);
 <span class="hljs-keyword">int</span> readdir_r(DIR <span class="hljs-variable">*dirp</span>, struct dirent <span class="hljs-variable">*entry</span>, struct dirent <span class="hljs-variable">**</span>result);</code></pre>

<p>readdir用来从参数dir所指向的目录中读取出目录项信息，返回一个struct dirent结构的指针</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> dirent
{
   ino_t          d_ino;       <span class="hljs-comment">/* inode number */</span>
   off_t          d_off;       <span class="hljs-comment">/* not an offset; see NOTES */</span>
   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> d_reclen;    <span class="hljs-comment">/* length of this record */</span>
   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>  d_type;      <span class="hljs-comment">/* type of file; not supported by
                                 all filesystem types */</span>
   <span class="hljs-keyword">char</span>           d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* filename */</span>
 };</code></pre>

<p>d_off是指目录文件开头至此目录进入点的位移，d_relen是指d_name的长度，d_name是指以NULL结尾的文件名。函数执行成功返回该目录下一个文件的信息，存储于dirent结构体中，如果调用opendir打开某个目录之后，第一次调用该函数，返回的是该目录下第一个文件的信息，第二次调用返回的是该目录下第二个文件的信息，依次类推，若该目录下已经没有文件可供读取(<strong>到达最后一个</strong>)，则返回NULL。 <br>
 3. closedir</p>



<pre class="prettyprint"><code class=" hljs cpp">  <span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
  <span class="hljs-preprocessor">#include &lt;dirent.h&gt;</span>
  <span class="hljs-keyword">int</span> closedir(DIR *dirp);</code></pre>

<p>closedir用来关闭dir参数指向的目录，执行成功返回0，有错误发生时返回-1。</p>
            <div>
                作者：zhuxinquan61 发表于2015/7/21 14:50:11 <a href="http://blog.csdn.net/zhuxinquan61/article/details/46986057">原文链接</a>
            </div>
            <div>
            阅读：66 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/46986057#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
        <item>
            <title><![CDATA[[原]linux系统编程——文件操作总结(2)]]></title>
            <link>http://blog.csdn.net/zhuxinquan61/article/details/46980629</link>
            <guid>http://blog.csdn.net/zhuxinquan61/article/details/46980629</guid>
            <author>zhuxinquan61</author>
            <pubDate>2015/7/21 9:02:39</pubDate>
            <description><![CDATA[
            <h4 id="1dup和dup2函数"><strong>1.dup和dup2函数</strong></h4>

<p>dup和dup2系统调用都可以用来复制文件描述符。复制成功返回最小且尚未使用的文件描述符，若有错误返回-1。返回的新的文件描述符和参数oldfd指向同一个文件，共享所有的锁定、读写指针和各项权限或标志位。dup2与dup的区别是dup2可以用参数newfd指定新文件描述符的数值。若newfd已经被程序使用系统就会将其关闭以释放该文件描述符，若newfd与oldfd相等，则dup2返回newfd而不关闭它，调用成功返回新的文件描述符，出错返回-1。</p>



<h4 id="2fcntl函数"><strong>2.fcntl函数</strong></h4>

<p>fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变<em>已打开文件</em>的各种属性。 <br>
int fcntl(int fd, int cmd, long arg); <br>
int fcntl(int fd, int cmd, struct flock *lock); <br>
fcntl的功能依据cmd值的不同而不同，具体有以下功能： <br>
(1).<strong>F_DUPFD</strong>：复制由fd指向的文件描述符，调用成功返回新的文件描述符，失败返回-1。 <br>
(2).<strong>F_GETFD</strong>：获取文件描述符的close-on-exce标志。调用成功返回标志值，若标志值最后一位为0，则该标志没有被设置，即意味着在执行exec相关函数后文件描述符仍然保持打开。否则在执行exec相关函数时将关闭该文件描述符，失败返回-1。 <br>
(3).<strong>F_SETFD</strong>：用来设置文件描述符的close-on- exec标志为第三个参数arg的最后一位。成功返回0，失败返回-1。 <br>
(4).<strong>F_GETFL</strong>：用来获得文件的打开方式，成功返回标志值，失败返回-1。 <br>
(5).<strong>F_SETFL</strong>：用来设置文件打开方式为第三个参数arg指定的方式。有O_APPEND、O_NONBLOCK、O_ASYNC标志。 <br>
文件记录锁：当有多个进程同时对一个文件进行操作时，就有可能发生数据的不同步,从而引发错误，该文件的最后状态取决于写该文件的最后一个程序。有时为确保它正在单独写一个文件，linux提供了记录锁机制。多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定的字节上写锁只能由一个进程单独使用。l_whence、l_start和l_len用来确定需要进行文件记录锁操作的区域，含义和lseek一致。为了锁整个文件，通常的方法是将l_start说明为0，l_whence说明为SEEK_SET，l_len说明为0. <br>
(6).<strong>F_SETLK</strong>：用来设置或者释放锁，当l_type取F_RDLCK或F_WDLCK时，则在指定的区域上设置锁，当取F_UNLCK时释放锁，若锁被其他进程占用，则返回-1。 <br>
(7).<strong>F_SETLKW</strong>：与F_SETLK时类似，不同是当希望设置的锁因为存在其他锁而被阻止设置时，该命令会等待相冲突的锁被释放。 <br>
(8).<strong>F_GETLK</strong> :第三个参数指向一个希望被设置的锁的属性的结构，若能被设置，并不真的设置，只是修改lock的l_type域为F_UNLCK，然后返回，若存在相冲突的锁，则返回一个锁的flock结构。 <br>
单个进程在同一字节上只能设置一种锁，新的锁会取代旧的锁，锁的不兼容规则是针对于多个进程之间的。 <br>
(9). <strong>F_GETOWN</strong>：返回当前接受的SIGIO或SIGURG信号，进程组ID以负值指定，进程ID用正值指定。 <br>
(10).<strong>F_SETOWN</strong>：设置进程或进程组接收SIGIO和SIGURG信号。 <br>
(11).<strong>F_GETSIG</strong>：在输入输出时，获得发送的信号。 <br>
(12).<strong>F_SETSIG</strong> ：设置在输入输出时发送的信号。</p>



<h4 id="3ioctl函数"><strong>3.ioctl函数</strong></h4>

<p>int ioctl(int fd, int request, …); <br>
ioctl系统调用通常用来控制设备，文件的属性，第一个参数fd必须是一个已经打开的文件描述符，第三个参数一般为char *argp,它随第二个参数的不同而不同，参数request决定了参数argp是向ioctl传递数据还是从ioctl获取参数。 <br>
如下代码是获取网络设备的信息：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//实例ioctl的使用</span>

<span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/ioctl.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;net/if.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>


<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g_eth_name[<span class="hljs-number">16</span>];
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g_macaddr[<span class="hljs-number">6</span>];
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g_subnetmask;
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g_ipaddr;
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g_broadcast_ipaddr;

<span class="hljs-comment">//初始化网络，获取当前网络设备的信息</span>
<span class="hljs-keyword">void</span> init_net(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> sock;
    <span class="hljs-keyword">struct</span> sockaddr_in <span class="hljs-built_in">sin</span>;
    <span class="hljs-keyword">struct</span> ifreq ifr;

    sock = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span>(sock == -<span class="hljs-number">1</span>)
    {
        perror(<span class="hljs-string">"socket"</span>);
    }
    <span class="hljs-built_in">strcpy</span>(g_eth_name, <span class="hljs-string">"eth0"</span>);
    <span class="hljs-built_in">strcpy</span>(ifr.ifr_name, g_eth_name);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"eth name:\t%s\n"</span>, g_eth_name);

    <span class="hljs-comment">//获取并打印网卡地址</span>
    <span class="hljs-keyword">if</span>(ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"ioctl"</span>);
    }
    <span class="hljs-built_in">memcpy</span>(g_macaddr, ifr.ifr_hwaddr.sa_data, <span class="hljs-number">6</span>);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"local mac:\t"</span>);
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2x:"</span>, g_macaddr[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2x\n"</span>, g_macaddr[i]);

    <span class="hljs-comment">//获取并打印IP地址</span>
    <span class="hljs-keyword">if</span>(ioctl(sock, SIOCGIFADDR, &amp;ifr) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"ioctl"</span>);
    }

    <span class="hljs-built_in">memcpy</span>(&amp;<span class="hljs-built_in">sin</span>, &amp;ifr.ifr_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));
    g_ipaddr = <span class="hljs-built_in">sin</span>.sin_addr.s_addr;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"local eth0:\t%s\n"</span>, inet_ntoa(<span class="hljs-built_in">sin</span>.sin_addr));

    <span class="hljs-comment">//获取并打印广播地址</span>
    <span class="hljs-keyword">if</span>(ioctl(sock, SIOCGIFBRDADDR, &amp;ifr) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"ioctl"</span>);
    }
    <span class="hljs-built_in">memcpy</span>(&amp;<span class="hljs-built_in">sin</span>, &amp;ifr.ifr_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));
    g_broadcast_ipaddr = <span class="hljs-built_in">sin</span>.sin_addr.s_addr;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"broadcast:\t%s\n"</span>, inet_ntoa(<span class="hljs-built_in">sin</span>.sin_addr));

    <span class="hljs-comment">//获取并打印子网掩码</span>
    <span class="hljs-keyword">if</span>(ioctl(sock, SIOCGIFNETMASK, &amp;ifr) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"ioctl"</span>);
    }
    <span class="hljs-built_in">memcpy</span>(&amp;<span class="hljs-built_in">sin</span>, &amp;ifr.ifr_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));
    g_subnetmask = <span class="hljs-built_in">sin</span>.sin_addr.s_addr;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"subnetmask:\t%s\n"</span>, inet_ntoa(<span class="hljs-built_in">sin</span>.sin_addr));

    close(sock);
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">//initialize</span>
    init_net();

    <span class="hljs-comment">//do something</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20150721110539311" alt="这里写图片描述" title=""></p>



<h4 id="4获取文件属性"><strong>4.获取文件属性</strong></h4>

<p>在shell下直接使用ls就可获取文件的属性，在程序中需要使用stat/fstat/lstat函数，执行成功返回0，失败返回-1。</p>



<pre class="prettyprint"><code class=" hljs perl">     <span class="hljs-comment">#include &lt;sys/types.h&gt;</span>
     <span class="hljs-comment">#include &lt;sys/stat.h&gt;</span>
     <span class="hljs-comment">#include &lt;unistd.h&gt;</span>
     <span class="hljs-keyword">int</span> <span class="hljs-keyword">stat</span>(const char <span class="hljs-variable">*path</span>, struct <span class="hljs-keyword">stat</span> <span class="hljs-variable">*buf</span>);
     <span class="hljs-keyword">int</span> fstat(<span class="hljs-keyword">int</span> fd, struct <span class="hljs-keyword">stat</span> <span class="hljs-variable">*buf</span>);
     <span class="hljs-keyword">int</span> <span class="hljs-keyword">lstat</span>(const char <span class="hljs-variable">*path</span>, struct <span class="hljs-keyword">stat</span> <span class="hljs-variable">*buf</span>);
</code></pre>

<p>stat用于获取由参数file_name指定的文件名的状态信息，保存在参数struct stat * buf中，fstat是通过文件描述符来指定文件的。lstat对于符号链接，返回的是符号链接本身的状态信息，而stat返回的是符号链接指向的文件状态信息。 <br>
参数struct stat *buf是一个保存文件状态信息的结构体，具体类型如下：</p>



<pre class="prettyprint"><code class=" hljs applescript">struct stat
{
  dev_t     st_dev;     /* ID <span class="hljs-keyword">of</span> device containing <span class="hljs-type">file</span> */
  ino_t     st_ino;     /* inode <span class="hljs-type">number</span> */
  mode_t    st_mode;    /* protection */
  nlink_t   st_nlink;   /* <span class="hljs-type">number</span> <span class="hljs-keyword">of</span> hard links */
  uid_t     st_uid;     /* user ID <span class="hljs-keyword">of</span> owner */
  gid_t     st_gid;     /* group ID <span class="hljs-keyword">of</span> owner */
  dev_t     st_rdev;    /* device ID (<span class="hljs-keyword">if</span> special <span class="hljs-type">file</span>) */
  off_t     st_size;    /* total size, <span class="hljs-keyword">in</span> bytes */
  blksize_t st_blksize; /* blocksize <span class="hljs-keyword">for</span> filesystem I/O */
  blkcnt_t  st_blocks;  /* <span class="hljs-type">number</span> <span class="hljs-keyword">of</span> <span class="hljs-number">512</span>B blocks allocated */
  time_t    st_atime;   /* <span class="hljs-property">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">last</span> access */
  time_t    st_mtime;   /* <span class="hljs-property">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">last</span> modification */
  time_t    st_ctime;   /* <span class="hljs-property">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">last</span> status change */
};
</code></pre>

<p>若某一目录具有sticky位(S_ISVTX),则表示在此目录下的文件只能被该文件所有者、此目录所有者或root来删除或改名。 <br>
对于st_mode包含的文件类型信息，POSIX标准定义了一系列的宏：</p>

<ol>
<li>S_ISLNK(st_mode):判读是否为符号链接</li>
<li>S_ISREG(st_mode):·判断是否为一般文件</li>
<li>S_ISDIR(st_mode):判断是否为目录文件</li>
<li>S_ISCHR(st_mode):判断是否是字符设备文件</li>
<li>S_ISBLK(st_mode):判断是否为块设备文件</li>
<li>S_ISFIFO(st_mode):判断是否为先进先出FIFO</li>
<li>S_ISSOCK(st_mode):判断是否为socket</li>
</ol>



<h4 id="5设置文件属性"><strong>5.设置文件属性</strong></h4>

<p><strong>1.hmode/fchmode</strong>：用于修改文件的存取权限 <br>
<strong>2.chown/fchown/lchown</strong>：用于修改文件的用户id和组id</p>



<pre class="prettyprint"><code class=" hljs cs">  <span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
  <span class="hljs-keyword">int</span> chown(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, uid_t owner, gid_t <span class="hljs-keyword">group</span>);
  <span class="hljs-keyword">int</span> fchown(<span class="hljs-keyword">int</span> fd, uid_t owner, gid_t <span class="hljs-keyword">group</span>);
  <span class="hljs-keyword">int</span> lchown(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, uid_t owner, gid_t <span class="hljs-keyword">group</span>);
</code></pre>

<p>chown将参数path指定的文件所有者id变更为参数owner代表的用户id，而将该文件所有者的组id变更为参数group组id。fchown只是以文件描述符作为参数的，lchown更改的是符号链接本身的所有者id，而不是该符号链接所指向的文件。 <br>
文件的所有者只能改变文件的组id为其所属组中的一个，超级用户才能修改文件的所有者id，并且超级用户可以任意修改文件的用户组id。如果参数owner或group指定为-1，那么文件的用户组id和组id不会改变。函数执行成功返回1，错误返回-1。 <br>
<strong>3.truncate/ftruncate</strong></p>



<pre class="prettyprint"><code class=" hljs perl">   <span class="hljs-comment">#include &lt;unistd.h&gt;</span>
   <span class="hljs-comment">#include &lt;sys/types.h&gt;</span>
   <span class="hljs-keyword">int</span> <span class="hljs-keyword">truncate</span>(const char <span class="hljs-variable">*path</span>, off_t <span class="hljs-keyword">length</span>);
   <span class="hljs-keyword">int</span> ftruncate(<span class="hljs-keyword">int</span> fd, off_t <span class="hljs-keyword">length</span>);
</code></pre>

<p>truncate将参数path指定的文件大小修改为length指定的大小。如果原来的文件大小比length大，则超过的部分会被删除，如果原来的文件大小比参数length小，则文件将被扩展，与lseek系统调用类似，文件扩展部分将以0填充，若文件的大小改变，则文件的st_time域和st_ctime域将会更新。 <br>
<strong>4.utime</strong> <br>
用于改变任何文件的st_time域和st_ctime域，即存取时间和修改时间。</p>



<pre class="prettyprint"><code class=" hljs cpp">  <span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
  <span class="hljs-preprocessor">#include &lt;utime.h&gt;</span>
  <span class="hljs-keyword">int</span> utime(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> utimbuf *times);

  <span class="hljs-preprocessor">#include &lt;sys/time.h&gt;</span>
  <span class="hljs-keyword">int</span> utimes(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval times[<span class="hljs-number">2</span>]);
</code></pre>

<p>参数struct utime *buf的定义如下：</p>



<pre class="prettyprint"><code class=" hljs cs">  <span class="hljs-keyword">struct</span> utimbuf
  {
     time_t actime;       <span class="hljs-comment">/* access time */</span>
     time_t modtime;      <span class="hljs-comment">/* modification time */</span>
  };
</code></pre>

<p>utime系统调用会把由第一个参数指向的filename指定的文件的存取时间改为第二个参数buf的actime域，把修改时间改为第二个参数buf的modtime域，如果buf是一个空指针，则存取时间和修改时间都将改为<strong>当前时间</strong>。 <br>
<strong>5.umask</strong> <br>
用于设置文件创建是使用的屏蔽字，并返回以前的值，在进程创建一个新文件或目录时，如调用open函数创建一个新文件，新文件的实际存取权限是mode与umask按照(mode &amp; ~umask)运算以后的结果，umask函数用来修改进程的umask。参数mask可以直接取数值也可以为open系统调用的第三个参数mode的11个宏或它们的组合。 <br>
具体参考如下：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>

<span class="hljs-keyword">int</span> main()
{
    umask(<span class="hljs-number">0</span>);   <span class="hljs-comment">//不屏蔽任何权限</span>
    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"example_681.test"</span>, S_IRWXU|S_IRWXG|S_IRWXO) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"creat"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    umask(S_IRWXO);     <span class="hljs-comment">//屏蔽其他用户的所有权限</span>
    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"example_682.test"</span>, S_IRWXU|S_IRWXO|S_IRWXG) &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"creat"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>执行结果如下：<img src="http://img.blog.csdn.net/20150721142441558" alt="这里写图片描述" title=""> <br>
   在第一次创建时未使用屏蔽任何选项得到的文件所有权限都在，而第二次屏蔽掉了其他用户的所有权限。</p>
            <div>
                作者：zhuxinquan61 发表于2015/7/21 9:02:39 <a href="http://blog.csdn.net/zhuxinquan61/article/details/46980629">原文链接</a>
            </div>
            <div>
            阅读：90 评论：0 <a href="http://blog.csdn.net/zhuxinquan61/article/details/46980629#comments" target="_blank">查看评论</a>
            </div>
        ]]>
            </description>
            <category></category>
        </item>
    </channel>
</rss>
